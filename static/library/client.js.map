{
  "version": 3,
  "sources": ["../../../toolbox/any/noOp.ts", "../../../toolbox/any/simpleModuleLogger.ts", "../../../toolbox/any/createElement/htmlBooleanAttributes.ts", "../../../toolbox/any/kebabize.ts", "../../../toolbox/any/escapeHTML.ts", "../../../toolbox/any/isObject.ts", "../../../toolbox/any/createElement/createElementDom.web.ts", "../../../toolbox/any/createElement/createElementTemplate.ts", "../../../toolbox/any/createElement/createElementProxy.ts", "../../../toolbox/any/createElement/h.web.ts", "../../../toolbox/any/debounce.ts", "../../../toolbox/any/getClampedRandomInt.ts", "../../../toolbox/any/splitPathStringToParts.ts", "../../../toolbox/any/symbols.ts", "../../../toolbox/any/identity.ts", "../../../toolbox/any/Signal.ts", "../../../toolbox/any/MapSignal.ts", "../../../toolbox/web/LocalStorageSignalAdapter.ts", "../../../toolbox/web/userMessagesCollection.ts", "../../../toolbox/any/toURLParams.ts", "../../../toolbox/web/enableOrDisableForm.ts", "../../../toolbox/web/handleSimpleFormSubmit.ts", "../../../toolbox/web/autoFetchWhenSubmit.ts", "../../../toolbox/web/processDomElementOnce.ts", "../../../toolbox/web/onScrollStopped.ts", "../../../toolbox/any/cleanupUrlString.ts", "../../../web-components/clientScript/api.ts", "../../../web-components/clientScript/env.ts", "../../../toolbox/web/getElementRelativePosition.ts", "../../../toolbox/web/isElementPartiallyVisibleInParent.ts", "../../../toolbox/web/scrollIntoViewIfPartiallyVisible.ts", "../../../toolbox/web/makeNodeSignalBinder.ts", "../../../toolbox/any/wait.ts", "../../../toolbox/any/UnreachableCaseError.ts", "../../../toolbox/any/ensureError.ts", "../../../toolbox/any/FetcherSignal.ts", "../../../toolbox/any/shuffleArray.ts", "../../../toolbox/any/searchParamsToObj.ts", "../../../toolbox/any/pick.ts", "../../../toolbox/web/querySelector.ts", "../../../toolbox/web/querySelectorAll.ts", "../../../toolbox/any/isNotNull.ts", "../../../toolbox/any/ensureAllElementsNotNull.ts", "../../../toolbox/any/DataBearingError.ts", "../../../toolbox/web/prefersReducedMotion.ts", "../../../web-components/clientScript/clientDependencies.ts", "../../../web-components/components/togglerButton.client.ts", "../../../web-components/components/betaMention.client.ts", "../../../web-components/components/carousel.client.ts", "../../../web-components/components/clapsGame.client.ts", "../../../web-components/components/clapsButton.client.ts", "../../../web-components/components/fileInText.client.ts", "../../../web-components/components/codeBlock.client.ts", "../../../web-components/components/collapsibleElement.client.ts", "../../../web-components/components/collapsibleList.client.ts", "../../../web-components/clientScript/searchEngine.ts", "../../../web-components/components/glossarySearch.client.ts", "../../../web-components/clientScript/mainSearchSuggestions.ts", "../../../web-components/components/mainSearch.client.ts", "../../../web-components/components/passwordField.client.ts", "../../../web-components/components/promoGDSchool.client.ts", "../../../web-components/components/userMessages.client.ts", "../../../web-components/components/scrollingList.client.ts", "../../../web-components/components/NodeFlashCard.client.ts", "../../../web-components/components/nodeFlashCardShuffler.client.ts", "../../../web-components/components/itemSummaryBrowser.client.ts", "../../../web-components/components/mailingListCollector.client.ts", "../../../web-components/components/tableOfContentsConsts.ts", "../../../web-components/clientScript/getViewPortSizeFromCss.ts", "../../../web-components/components/tableOfContents.client.ts", "../../../web-components/components/tabList.client.ts", "../../../web-components/components/themeToggle.client.ts", "../../../web-components/components/videoFile.client.ts", "../../../web-components/components/anchorClipboardButton.client.ts", "../../../web-components/components/clipboardButton.client.ts", "../../../web-components/clientScript/scrollSpy.ts", "../../../web-components/client.ts"],
  "sourcesContent": ["export const noOp: (...args: unknown[]) => void = () => {};\n", "import { noOp } from \"./noOp.ts\";\n\ntype ConsoleMethodNames =\n  | \"log\"\n  | \"error\"\n  | \"info\"\n  | \"warn\"\n  | \"assert\"\n  | \"trace\"\n  | \"table\";\n\ntype SimpleConsoleMethods = Pick<Console, ConsoleMethodNames>;\n\n// using an object ensures Typescript verifies all keys of the union type are present, and no extra keys are added\nconst consoleMethodsKeys: Record<ConsoleMethodNames, null> = {\n  \"log\": null,\n  \"error\": null,\n  \"info\": null,\n  \"warn\": null,\n  \"assert\": null,\n  \"trace\": null,\n  \"table\": null,\n};\n\nconst consoleMethods = Object.keys(consoleMethodsKeys) as ConsoleMethodNames[];\n\nconst noOpLogger: SimpleConsoleMethods = consoleMethods.reduce(\n  (receiver: SimpleConsoleMethods, k) => {\n    receiver[k] = noOp;\n    return receiver;\n  },\n  {} as SimpleConsoleMethods,\n);\n\nclass SimpleConsole implements SimpleConsoleMethods {\n  constructor(public prefix: string[]) {}\n  log(...args: unknown[]) {\n    console.log(...this.prefix, ...args);\n  }\n  error(...args: unknown[]) {\n    console.error(...this.prefix, ...args);\n  }\n  info(...args: unknown[]) {\n    console.info(...this.prefix, ...args);\n  }\n  warn(...args: unknown[]) {\n    console.warn(...this.prefix, ...args);\n  }\n  assert(condition: boolean, ...args: unknown[]) {\n    console.assert(condition, ...this.prefix, ...args);\n  }\n  trace(...args: unknown[]) {\n    console.trace(...this.prefix, ...args);\n  }\n  table(data: unknown, columns?: string[]) {\n    console.table(data, columns);\n  }\n}\n\n/**\n * Creates a logger that logs messages to the console.\n * The logger can be enabled or disabled based on the URL parameters when used in the browser.\n * When used from the CLI, you may pass a query string to enable specific modules.\n *\n * If both the query string and the URL parameters are empty, the query string will have priority.\n *\n * If the \"debug\" parameter is present, it will log messages with the specified title.\n * To specify which modules to enable, use the \"debug\" parameter in the URL, e.g., `?debug=module1,module2`.\n *\n * Then, when creating loggers, use the module name as the title:\n * ```ts\n * const makeLogger = simpleModuleLogger();\n * const logger = makeLogger(\"module1\");\n *\n * logger.log(\"This is a log message for module1\");\n * ```\n * * If the \"debug\" parameter is not present, or if the `*` module is selected, then all modules are enabled by default.\n */\nexport const simpleModuleLogger = (query = \"\") => {\n  const params = !query && globalThis && globalThis.location\n    ? new URLSearchParams(globalThis.location.search)\n    : new URLSearchParams(query);\n\n  const enabledModules = (params.get(\"debug\") || \"*\")\n    .split(\",\")\n    .filter(Boolean)\n    .reduce((receiver, k) => {\n      receiver.add(k.trim());\n      return receiver;\n    }, new Set<string>());\n\n  const allModulesEnabled = enabledModules.has(\"*\");\n\n  return function moduleLogger(\n    title: string,\n    color: string = \"#5b5bdf\",\n  ): SimpleConsoleMethods {\n    if (allModulesEnabled || enabledModules.has(title)) {\n      return new SimpleConsole([`%c[${title}]`, `color:${color};`]);\n    }\n    return noOpLogger;\n  };\n};\n", "export const htmlBooleanAttributes = [\n  \"allowfullscreen\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"inert\",\n  \"ismap\",\n  \"itemscope\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\",\n  \"shadowrootclonable\",\n  \"shadowrootdelegatesfocus\",\n  \"shadowrootserializable\",\n  \"async\",\n  \"defer\",\n  \"popover\",\n];\n\nconst htmlBooleanAttributesSet = new Set(htmlBooleanAttributes);\n\nexport type HTMLBooleanAttribute = (typeof htmlBooleanAttributes)[number];\n\nexport const isHTMLBooleanAttribute = (\n  value: string,\n): value is HTMLBooleanAttribute =>\n  htmlBooleanAttributesSet.has(value as HTMLBooleanAttribute);\n", "/**\n * Converts a camelCase string to kebab-case\n * @param str any string\n */\nexport const kebabize = (str: string): string =>\n  str.replace(\n    /[A-Z]+(?![a-z])|[A-Z]/g,\n    ($, ofs) => (ofs ? \"-\" : \"\") + $.toLowerCase(),\n  );\n", "const escapeReplacements: { [index: string]: string } = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#039;\",\n};\n\nconst other = {\n  escapeTest: /[&<>\"']/,\n  escapeReplace: /[&<>\"']/g,\n  escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n  escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n};\n\nconst getEscapeReplacement = (ch: string) => escapeReplacements[ch];\n\n/**\n * Escapes HTML special characters in a string. Useful for `<code>` blocks.\n */\nexport function escapeHTML(html: string, encode?: boolean) {\n  if (encode) {\n    if (other.escapeTest.test(html)) {\n      return html.replace(other.escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (other.escapeTestNoEncode.test(html)) {\n      return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n", "/**\n * Shortcut for Object.getPrototypeOf\n */\nexport const protoOf: (a: unknown) => object = Object.getPrototypeOf;\n\n/**\n * Object prototype, use it for comparisons\n */\nexport const objProto = protoOf({});\n\n/**\n * Checks if a value is a plain object.\n * TODO: Check if this version or `isPlainObject` is more accurate.`\n */\nexport const isObject = (value: unknown): value is Record<string, unknown> =>\n  typeof value === \"object\" && protoOf(value) === objProto;\n", "import { isHTMLBooleanAttribute } from \"./htmlBooleanAttributes.ts\";\nimport type { HTMLFactory } from \"./types.ts\";\nimport { kebabize } from \"../kebabize.ts\";\nimport { escapeHTML } from \"../escapeHTML.ts\";\nimport { isObject } from \"../isObject.ts\";\n\n/**\n * Creates a DOM element with the given tag name, attributes, and children.\n *\n * @param tagName The tag name of the element to create.\n * @param attributes The attributes to set on the element.\n * @param children The children to append to the element.\n * @returns The created element.\n */\nexport const createElementDom: HTMLFactory.CreateElement<\"client\"> = <\n  K extends keyof HTMLElementTagNameMap\n>(\n  tagName: K,\n  ...props: (HTMLFactory.Attributes<K> | null | HTMLFactory.ValidChild)[]\n) => {\n  const element = document.createElement(tagName);\n  const [attributes, ...children] = (\n    isObject(props[0] || props[0] == null) ? props : [null, ...props]\n  ) as [HTMLFactory.Attributes<K> | null, ...HTMLFactory.ValidChild[]];\n  attributes &&\n    Object.entries(attributes).forEach(([k, v]) => {\n      if (typeof v === \"function\") {\n        const fn = v as\n          | HTMLFactory.BindedFunction\n          | EventListenerOrEventListenerObject;\n        if (k.startsWith(\"on\")) {\n          const listener = fn as EventListenerOrEventListenerObject;\n          const event = k.slice(2).toLowerCase();\n          element.addEventListener(event, listener);\n        } else {\n          // @ts-expect-error: way too complicated to type properly\n          fn(element, k);\n        }\n      } else if (k.startsWith(\"aria\")) {\n        const property = \"aria-\" + kebabize(k.slice(4));\n        element.setAttribute(property, v + \"\");\n      } else if (k.startsWith(\"data\")) {\n        if (v === null) {\n          return;\n        }\n        const property = \"data-\" + kebabize(k.slice(4));\n        element.setAttribute(property, v + \"\");\n      } else if (k === \"acceptCharset\") {\n        return `accept-charset=\"${escapeHTML(v + \"\")}\"`;\n      } else if (k === \"colorScheme\") {\n        return `color-scheme=\"${escapeHTML(v + \"\")}\"`;\n      } else if (k === \"themeColor\") {\n        return `theme-color=\"${escapeHTML(v + \"\")}\"`;\n      } else if (k === \"httpEquiv\") {\n        return `http-equiv=\"${escapeHTML(v + \"\")}\"`;\n      } else if (k === \"className\" || k === \"class\") {\n        const classValue = v as HTMLFactory.ClassNameValue;\n        if (classValue == null || classValue === false) {\n          return;\n        }\n        if (Array.isArray(classValue)) {\n          // If I use the more appropriate `@ts-expect-error`, ts will sometimes complain that the annation is useless, because it can totally infer the type\n          // but if I remove it, it will sometimes complain that the type is infinitely deep.\n          //@ts-ignore typescript can't handle infinity... sometimes.\n          const classes = classValue.flat(Infinity).filter(Boolean) as string[];\n          element.classList.add(...classes);\n        } else {\n          if (classValue.includes(\" \")) {\n            throw new Error(\"Invalid class name: \" + v);\n          }\n          element.classList.add(v + \"\");\n        }\n      } else if (k === \"props\") {\n        const propsValue = v as HTMLFactory.Props;\n        Object.entries(propsValue).forEach(([prop, value]) => {\n          // TODO: properly type props\n          // @ts-expect-error: this is an escape hatch\n          element[prop] = value;\n        });\n      } else if (v === false && isHTMLBooleanAttribute(k)) {\n        return;\n      } else if (k === \"style\") {\n        if (v == null || v === false) {\n          return;\n        }\n        if (typeof v === \"string\") {\n          element.setAttribute(\"style\", escapeHTML(v));\n        } else {\n          const styleValue = v as Partial<CSSStyleDeclaration>;\n          return Object.entries(styleValue).forEach(([prop, value]) =>\n            element.style.setProperty(prop, value + \"\")\n          );\n        }\n      } else if (v === null) {\n        return;\n      } else {\n        element.setAttribute(k, v + \"\");\n      }\n    });\n  children &&\n    children.map(\n      (c) =>\n        c != null &&\n        c !== false &&\n        element.append(\n          Array.isArray(c)\n            ? createElementDom(...(c as Parameters<typeof createElementDom>))\n            : typeof c === \"string\" || typeof c === \"number\"\n            ? document.createTextNode(c + \"\")\n            : typeof c === \"function\"\n            ? c(document.createTextNode(\"\"), \"textContent\") ?? \"\"\n            : c\n        )\n    );\n  return element;\n};\n", "import type { HTMLFactory } from \"./types.ts\";\n\n/**\n * Binds a tagname and optional properties\n * @param createElement the function that creates the element\n * @param tagName the base tagname\n * @param baseAttributes if provided, will be merged with passed properties\n */\nexport const createElementTemplate = <\n  K extends keyof HTMLElementTagNameMap,\n  Mode extends \"client\" | \"server\",\n>(\n  createElement: HTMLFactory.CreateElement<Mode>,\n  tagName: K,\n  baseAttributes?: HTMLFactory.Attributes<K> | null,\n) => {\n  return (\n    attributes?: HTMLFactory.Attributes<K> | null,\n    ...children: HTMLFactory.ValidChild[]\n  ): Mode extends \"client\" ? HTMLElementTagNameMap[K] : string => {\n    return createElement(\n      tagName,\n      baseAttributes != null\n        ? { ...baseAttributes, ...attributes }\n        : attributes,\n      ...children,\n    ) as Mode extends \"client\" ? HTMLElementTagNameMap[K] : string;\n  };\n};\n\n/**\n *\nimport { createElementDom } from \"./createElementDom.web.ts\";\nimport { createElementString } from \"./createElementString.ts\";\n\n// Client-side usage - no need to specify types explicitly\nconst createElementTemplateDom = createElementTemplate(createElementDom, \"div\");\nconst div = createElementTemplateDom(); // Still correctly typed as HTMLDivElement\n\n// You can also make specific tag templates with inference\nconst a = createElementTemplate(createElementDom, \"a\");\n// a() will return HTMLAnchorElement\n\n// Server-side usage with inference\nconst createH1String = createElementTemplate(createElementString, \"h1\");\nconst h1 = createH1String()\n*/\n", "import type { HTMLFactory } from \"./types.ts\";\nimport { createElementTemplate } from \"./createElementTemplate.ts\";\nimport { kebabize } from \"../kebabize.ts\";\n\n/**\n * Creates a proxy that generates element creators on demand\n * @param createElement The function that creates the element\n * @returns A proxy object that generates element creators for any valid HTML tag\n */\nexport const createElementsProxy = <\n  Mode extends \"client\" | \"server\",\n  F,\n  Methods extends Record<string, F>\n>(\n  createElement: HTMLFactory.CreateElement<Mode>,\n  methods?: Methods\n) => {\n  // Cache for created element functions\n  const cache = new Map<string, ReturnType<typeof createElementTemplate>>();\n\n  // Create the proxy\n  return new Proxy(createElement, {\n    get(_target, prop) {\n      const tagName = prop.toString();\n\n      if (methods && tagName in methods) {\n        return methods[tagName];\n      }\n\n      // Return from cache if already created\n      if (cache.has(tagName)) {\n        return cache.get(tagName);\n      }\n\n      // Check if it's a valid HTML tag name\n      if (typeof tagName === \"string\") {\n        const htmlTagName = kebabize(tagName);\n        if (!isValidHTMLTag(htmlTagName)) {\n          return undefined;\n        }\n        const elementCreator = createElementTemplate(\n          createElement,\n          htmlTagName as keyof HTMLElementTagNameMap\n        );\n\n        // Cache the creator function\n        cache.set(tagName, elementCreator);\n        return elementCreator;\n      }\n\n      return undefined;\n    },\n  }) as HTMLFactory.CreateElement<Mode> &\n    Methods & {\n      [K in keyof HTMLElementTagNameMap]: HTMLFactory.BoundElementCreator<\n        K,\n        Mode\n      >;\n    } & {\n      [key: string]: HTMLFactory.BoundElementCreator<\"div\", Mode>;\n    };\n};\n\n// TODO: is this necessary?\nconst isValidHTMLTag = (\n  tagName: string\n): tagName is keyof HTMLElementTagNameMap => {\n  return typeof document !== \"undefined\"\n    ? document.createElement(tagName) instanceof HTMLElement\n    : /^[a-z][a-z0-9-]*$/i.test(tagName);\n};\n", "import { createElementDom } from \"./createElementDom.web.ts\";\nimport { createElementsProxy } from \"./createElementProxy.ts\";\n\nexport const appendChildren = (parent: HTMLElement, ...children: Child[]) => {\n  (children as ChildScalar[]).flat(Infinity).forEach((child) => {\n    if (child == null || child === false) {\n      return;\n    }\n    parent.append(child);\n  });\n};\n\nexport const clearAllChildren = (parent: HTMLElement) => {\n  while (parent.firstChild) {\n    parent.firstChild.remove();\n  }\n};\n\nexport const replaceAllChildren = (\n  parent: HTMLElement,\n  ...children: Child[]\n) =>\n  parent.replaceChildren(\n    ...(children as ChildScalar[]).flat(Infinity) as Node[],\n  );\n\nexport const h = createElementsProxy(createElementDom, {\n  add: appendChildren,\n  clear: clearAllChildren,\n  replace: replaceAllChildren,\n});\n\ntype ChildScalar = Node | string | undefined | null | false;\ntype Child = ChildScalar | ChildScalar[] | Child[];\n", "/**\n * Ensures a function only runs once it has stopped being called for a certain amount of time.\n * Useful for: resize events, scroll events, etc.\n * @param fn\n * @param delay defaults to 250ms\n */\nexport const debounce = (fn: () => void, delay = 250) => {\n  let debounceTimeOut: number | undefined;\n  return () => {\n    clearTimeout(debounceTimeOut);\n    debounceTimeOut = setTimeout(() => {\n      fn();\n    }, delay);\n  };\n};\n", "/**\n * Returns a random integer between min and max (inclusive)\n */\nexport const getClampedRandomInt = (max: number, min = 0) =>\n  Math.floor(Math.random() * (max - min + 1)) + min;\n", "const pathRegex =\n  /^(?:(?<protocol>\\w+):\\/)?\\/*(?<dir>.+\\/)?(?<filename>(?<basename>.+?)(?:\\.(?<extension>\\w+))?)$/;\n\nconst getFileTypeFromExtension = (extension?: string) => {\n  if (extension == null) {\n    return \"directory\";\n  }\n  switch (extension.toLowerCase()) {\n    case \"gd\":\n      return \"gdscript\";\n    case \"tscn\":\n      return \"scene\";\n    case \"png\":\n    case \"jpg\":\n    case \"gif\":\n      return \"image\";\n    case \"ini\":\n    case \"text\":\n    case \"yaml\":\n    case \"txt\":\n      return \"text\";\n    default:\n      return \"file\";\n  }\n};\n\ntype PathParts = {\n  /** Protocol, sans ://. Example values: `http`, `sftp`, `res`. Defaults to `res` (if it defaults, `incomplete` will be set to `true`) */\n  protocol: string;\n  /** extension, or `directory` if no extension was found. */\n  fileType: Lowercase<ReturnType<typeof getFileTypeFromExtension>>;\n  /** full directory path, without protocol or filename, e.g., `path/to/` */\n  dirname: string[];\n  /** only the filename, including extension, e.g. `file.gd` */\n  filename: string;\n  /** only the filename, without extension, e.g. `file` */\n  basename: string;\n  /** full path _without_ protocol , e.g. `path/to/file.gd` */\n  fullPath: string[];\n  /** full path _with_ protocol, e.g. `res://path/to/file.gd` */\n  href: string[];\n  /** extension of the file, without the preceeding dot, with case conserved, e.g. `gd` */\n  extension: string;\n  /** Is `true` if no protocol was provided and one defaulted to */\n  incomplete: boolean;\n};\n\nconst DEFAULT_REGEX_VALUES = {\n  protocol: \"\",\n  dir: \"\",\n  filename: \"\",\n  basename: \"\",\n  extension: \"\",\n};\n\n/**\n * Splits a path string into its constituent parts.\n */\nexport const splitPathStringToParts = (path: string) => {\n  path = path.replace(/^\\/+/, \"\");\n  const {\n    protocol: _protocol,\n    dir,\n    filename,\n    basename,\n    extension,\n  } = path.match(pathRegex)?.groups ?? DEFAULT_REGEX_VALUES;\n  const dirname = dir != null ? dir.replace(/\\/+$/, \"\").split(\"/\") : [];\n  const incomplete = typeof _protocol === \"undefined\";\n  const protocol = _protocol ?? \"res\";\n  const fullPath = [dir, filename].filter(Boolean) as string[];\n  const href = [protocol, ...dirname, filename].filter(Boolean) as string[];\n  const fileType = getFileTypeFromExtension(extension);\n  const parts: PathParts = {\n    href,\n    fullPath,\n    dirname,\n    filename,\n    protocol,\n    basename,\n    extension,\n    fileType,\n    incomplete,\n  };\n  return parts;\n};\n", "export const SKIP = Symbol(\"SKIP\");\nexport const CANCEL = Symbol(\"CANCEL\");\nexport const ABORT = Symbol(\"ABORT\");\nexport const NONE = Symbol(\"NONE\");\n\nexport type SKIP = typeof SKIP;\nexport type CANCEL = typeof CANCEL;\nexport type ABORT = typeof ABORT;\nexport type NONE = typeof NONE;\n", "/**\n * Returns the passed object\n */\nexport const identity = <T>(value: T): T => value;\n\nexport type Identity = <T>(value: T) => T;\n", "import { SKIP } from \"./symbols.ts\";\nimport { identity } from \"./identity.ts\";\n\nexport interface SignalTransform<T, R = T> {\n  (newValue: T, oldValue: T, skip: SKIP): T | SKIP;\n  (newValue: R, oldValue: T, skip: SKIP): T | SKIP;\n}\n\nexport interface SignalOptions<T, R> {\n  /**\n   * A function to transform the value as it comes in. can return SKIP to skip rerendering\n   * @param newValue\n   * @param oldValue\n   * @param skip the SKIP value. Return it to skip rerendering\n   * @returns\n   */\n  transform?: SignalTransform<T, R>;\n}\n\n/**\n * A reactive value.\n * @param value initial value\n * @param options\n * @returns\n */\nexport const Signal = <\n  T,\n  R = T,\n  Listener extends (v: T, o: T) => void = (v: T, o: T) => void\n>(\n  value: T,\n  { transform = identity }: SignalOptions<T, R> = {}\n) => {\n  const listeners = new Set<Listener>();\n\n  /**\n   * Listen when a new value is set\n   */\n  const on = (fn: Listener) => {\n    listeners.add(fn);\n    return signal;\n  };\n\n  /**\n   * Removes a listener\n   */\n  const off = (fn: Listener) => {\n    listeners.delete(fn);\n    return signal;\n  };\n\n  /**\n   * Set a new value\n   * @param newValue the new value to set\n   * @param forceRefresh if true, signal will be emitted even if the new value is equal to the old one.\n   *                     a signal will _not_ be emitted if the mapping function returns `SKIP` though.\n   */\n  const set = (newValue: R, forceRefresh = false) => {\n    const derivedValue = transform(newValue, value, SKIP);\n    if (derivedValue === SKIP || (!forceRefresh && derivedValue === value)) {\n      return signal;\n    }\n    const oldValue = value;\n    value = derivedValue;\n    listeners.forEach((fn) => fn(value, oldValue));\n    return signal;\n  };\n\n  /**\n   * Read the current value\n   */\n  const get = () => value;\n\n  const signal = { on, off, set, get };\n  return signal;\n};\n\nexport type Signal<T, R> = ReturnType<typeof Signal<T, R>>;\n", "import { Signal, type SignalOptions } from \"./Signal.ts\";\nimport { identity } from \"./identity.ts\";\n\ntype MapSignalListener<T> = (\n  key: keyof T,\n  value: T[keyof T],\n  oldValue?: T[keyof T],\n) => void;\ntype MapSignalListenerRemovalOrAdditions<T> = (\n  key: keyof T,\n  value: T[keyof T],\n) => void;\n\ninterface MapSignal<T> extends Signal<T, T> {\n  setItem: (key: keyof T, value: T[keyof T]) => void;\n  getItem: (key: keyof T) => T[keyof T];\n  hasItem: (key: keyof T) => boolean;\n  removeItem: (key: keyof T) => void;\n  onKeyAdded: (fn: MapSignalListenerRemovalOrAdditions<T>) => void;\n  offKeyAdded: (fn: MapSignalListenerRemovalOrAdditions<T>) => void;\n  onKeyRemoved: (fn: MapSignalListenerRemovalOrAdditions<T>) => void;\n  offKeyRemoved: (fn: MapSignalListenerRemovalOrAdditions<T>) => void;\n  onKeyChanged: (fn: MapSignalListener<T>) => void;\n  offKeyChanged: (fn: MapSignalListener<T>) => void;\n}\n\n/**\n * Reactive hashmap. Builds on {@link Signal}\n */\nexport const MapSignal = <T extends Record<string, unknown>>(\n  value: T,\n  { transform = identity }: SignalOptions<T, T> = {},\n): MapSignal<T> => {\n  const signal = Signal<T>(value, { transform });\n\n  const listenersForAdditions = new Set<\n    MapSignalListenerRemovalOrAdditions<T>\n  >();\n  const listenersForRemovals = new Set<\n    MapSignalListenerRemovalOrAdditions<T>\n  >();\n  const listenersForChange = new Set<MapSignalListener<T>>();\n\n  const setItem = (key: keyof T, value: T[keyof T]) => {\n    const oldData = signal.get();\n    const newData = { ...oldData, [key]: value };\n    signal.set(newData);\n    if (!(key in oldData)) {\n      listenersForAdditions.forEach((fn) => fn(key, value));\n    } else if (oldData[key] === value) {\n      return;\n    } else {\n      listenersForChange.forEach((fn) => fn(key, value, oldData[key]));\n    }\n  };\n\n  const getItem = (key: keyof T) => signal.get()[key];\n\n  const hasItem = (key: keyof T) => key in signal.get();\n\n  const removeItem = (key: keyof T) => {\n    const oldData = signal.get();\n    if (!(key in oldData)) {\n      return;\n    }\n    const { [key]: _delete, ...newData } = oldData;\n    listenersForRemovals.forEach((fn) => fn(key, oldData[key] as T[keyof T]));\n    signal.set(newData as T);\n  };\n\n  const onKeyAdded = (fn: MapSignalListenerRemovalOrAdditions<T>) =>\n    listenersForAdditions.add(fn);\n  const offKeyAdded = (fn: MapSignalListenerRemovalOrAdditions<T>) =>\n    listenersForAdditions.delete(fn);\n\n  const onKeyRemoved = (fn: MapSignalListenerRemovalOrAdditions<T>) =>\n    listenersForRemovals.add(fn);\n  const offKeyRemoved = (fn: MapSignalListenerRemovalOrAdditions<T>) =>\n    listenersForRemovals.delete(fn);\n\n  const onKeyChanged = (fn: MapSignalListener<T>) => listenersForChange.add(fn);\n  const offKeyChanged = (fn: MapSignalListener<T>) =>\n    listenersForChange.delete(fn);\n\n  return {\n    ...signal,\n    setItem,\n    getItem,\n    hasItem,\n    removeItem,\n    onKeyAdded,\n    offKeyAdded,\n    onKeyRemoved,\n    offKeyRemoved,\n    onKeyChanged,\n    offKeyChanged,\n  };\n};\n", "import type { Signal } from \"../any/Signal.ts\";\n\n/**\n * Creates a localstorage adapter around the provided signal and returns the signal.\n * It:\n *  - sets the initial value of the signal to the value stored in localstorage.\n *     If you have any listeners attached to the signal, they will be called\n *     with this value. Therefore, it is intended that this adapter is used\n *     before any listeners are attached to the signal.\n *     If any value was assigned to the signal, it will be _replaced_.\n *   - stores the value of the signal in localstorage any time the signal is updated.\n * @param signal any signal-compliant object\n * @param localStorageKey a unique string to identify the value in localstorage\n * @returns the signal passed.\n */\n// deno-lint-ignore no-explicit-any\nexport const LocalStorageSignalAdapter = <S extends Signal<any, any>>(\n  signal: S,\n  localStorageKey: string,\n): S => {\n  const value = JSON.parse(\n    localStorage.getItem(localStorageKey) || JSON.stringify(signal.get()),\n  );\n  signal.set(value);\n  signal.on((value) =>\n    localStorage.setItem(localStorageKey, JSON.stringify(value))\n  );\n\n  return signal;\n};\n", "import { MapSignal } from \"../any/MapSignal.ts\";\nimport { LocalStorageSignalAdapter } from \"./LocalStorageSignalAdapter.ts\";\n\nexport const TYPE_SUCCESS = \"success\";\nexport const TYPE_ERROR = \"error\";\nexport const TYPE_INFO = \"info\";\nexport const TYPE_WARNING = \"warning\";\n\nexport type UserMessageType =\n  | typeof TYPE_SUCCESS\n  | typeof TYPE_ERROR\n  | typeof TYPE_INFO\n  | typeof TYPE_WARNING;\n\ntype MessageRepository = Record<\n  string,\n  { message: string; type: UserMessageType }\n>;\n\ninterface UserMessagesCollection {\n  add: (\n    type: UserMessageType,\n    message: string,\n    id?: string,\n  ) => string;\n  addSuccess: (message: string) => string;\n  addError: (message: string) => string;\n  addInfo: (message: string) => string;\n  addWarning: (message: string) => string;\n  remove: (id: string) => void;\n  get: (id: string) => { message: string; type: UserMessageType } | undefined;\n  entries: () => [string, { message: string; type: UserMessageType }][];\n\n  onMessageAdded: (\n    fn: (\n      key: string,\n      value: { message: string; type: UserMessageType },\n    ) => void,\n  ) => void;\n  onMessageRemoved: (\n    fn: (\n      key: string,\n      value?: { message: string; type: UserMessageType },\n    ) => void,\n  ) => void;\n  offMessageAdded: (\n    fn: (\n      key: string,\n      value: { message: string; type: UserMessageType },\n    ) => void,\n  ) => void;\n  offMessageRemoved: (\n    fn: (\n      key: string,\n      value?: { message: string; type: UserMessageType },\n    ) => void,\n  ) => void;\n}\n\n/**\n * A collection of messages that are displayed to the user.\n * Each message gets recorded to localstorage, so it continues to show between refreshes.\n * This library doesn't handle the display of the messages, only the storage and retrieval.\n */\nconst makeUserMessagesCollection = (): UserMessagesCollection => {\n  const signal = LocalStorageSignalAdapter(\n    MapSignal({} as MessageRepository),\n    \"__userMessages\",\n  );\n\n  const add = (type: UserMessageType, message: string, id?: string) => {\n    id = id ||\n      `usermessage-` + type + \"-\" + Math.random().toString(36).slice(2);\n    signal.setItem(id, { message, type });\n    return id;\n  };\n\n  const addSuccess = (message: string) => add(TYPE_SUCCESS, message);\n  const addError = (message: string) => add(TYPE_ERROR, message);\n  const addInfo = (message: string) => add(TYPE_INFO, message);\n  const addWarning = (message: string) => add(TYPE_WARNING, message);\n\n  const remove = (id: string) => signal.removeItem(id);\n\n  const get = (id: string) => signal.getItem(id);\n  const entries = () => Object.entries(signal.get());\n\n  return {\n    add,\n    addSuccess,\n    addError,\n    addInfo,\n    addWarning,\n    remove,\n    get,\n    entries,\n    onMessageAdded: signal.onKeyAdded,\n    onMessageRemoved: signal.onKeyRemoved,\n    offMessageAdded: signal.offKeyAdded,\n    offMessageRemoved: signal.offKeyRemoved,\n  };\n};\n\nlet _cache: UserMessagesCollection | null = null;\n\nexport const userMessagesCollection = (): UserMessagesCollection => {\n  if (!_cache) {\n    _cache = makeUserMessagesCollection();\n  }\n  return _cache;\n};\n", "/**\n * Converts an object or FormData to a URLSearchParams string.\n */\nexport const toURLParams = (values: FormData | Record<string, unknown>) =>\n  (values instanceof FormData\n    ? Array.from(values.entries())\n    : Object.entries(values))\n    .map(([k, v]) =>\n      Array.isArray(v)\n        ? v.map((vv) => `${k}=${encodeURIComponent(vv)}`).join(\"&\")\n        : typeof v === \"string\" || typeof v === \"number\"\n        ? `${k}=${encodeURIComponent(v)}`\n        : typeof v === \"boolean\"\n        ? `${k}=${v ? \"true\" : \"false\"}`\n        : `${k}=${encodeURIComponent(JSON.stringify(v))}`\n    )\n    .join(\"&\");\n", "export type HTMLFormControlElement =\n  | HTMLInputElement\n  | HTMLSelectElement\n  | HTMLTextAreaElement\n  | HTMLButtonElement\n  | HTMLFieldSetElement\n  | HTMLOutputElement\n  | HTMLObjectElement;\n\nexport const disableForm = (form: HTMLFormElement): void => {\n  let length = form.elements.length;\n  while (length--) {\n    const control = form.elements[length] as HTMLFormControlElement;\n    if (\"disabled\" in control) {\n      control.disabled = true;\n    }\n  }\n};\n\nexport const enableForm = (form: HTMLFormElement): void => {\n  let length = form.elements.length;\n  while (length--) {\n    const control = form.elements[length] as HTMLFormControlElement;\n    if (\"disabled\" in control) {\n      control.disabled = false;\n    }\n  }\n};\n", "import type { HttpMethod } from \"../types/mod.ts\";\nimport type { SerializedForm } from \"./serializeComplicatedForm.ts\";\n\nexport type SimpleSerializedForm = Omit<SerializedForm, \"values\" | \"method\"> & {\n  values: FormData;\n  method: HttpMethod | \"\";\n};\n\ntype FormHandler = (\n  serialized: SimpleSerializedForm,\n  form: HTMLFormElement,\n) => void;\n\n/**\n * A wrapper that simplifies form submission handling.\n * It prevents default form submission behavior, stops event propagation,\n * and serializes the form data into a simplified format, ready to be used in\n * various contexts such as API requests or client-side validation.\n * **note**: this serialization method uses `FormData` to serialize form data; for complex forms with\n * repeating fields, conditions, or nested structures, consider using the more expensive method\n * [serializeComplicatedForm]({@link ./serializeComplicatedForm.ts})\n */\nexport const handleSimpleFormSubmit =\n  (callback: FormHandler) => (event: SubmitEvent | Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n    const form = event.target as HTMLFormElement;\n    const action = form.getAttribute(\"action\") || \"\";\n    const formName = form.getAttribute(\"name\") || \"\";\n    const enctype = form.getAttribute(\"enctype\") || \"\";\n    const method = (form.getAttribute(\"method\") || \"\")\n      .toUpperCase() as (HttpMethod | \"\");\n    const target = form.getAttribute(\"target\") || \"\";\n    const values = new FormData(form);\n\n    const serialized: SimpleSerializedForm = {\n      name: formName,\n      action,\n      method,\n      values,\n      enctype,\n      target,\n    };\n\n    callback(serialized, form);\n  };\n", "import { toURLParams } from \"../any/toURLParams.ts\";\nimport { disableForm, enableForm } from \"./enableOrDisableForm.ts\";\nimport {\n  handleSimpleFormSubmit,\n  type SimpleSerializedForm,\n} from \"./handleSimpleFormSubmit.ts\";\nimport type { HttpMethod } from \"../types/HttpMethod.ts\";\n\ntype AllowedMethodTypes = HttpMethod | \"JSON\" | \"AUTO\";\n\nconst pickCorrectFetch = (\n  type: AllowedMethodTypes,\n  serialized: SimpleSerializedForm,\n) => {\n  if (type === \"AUTO\") {\n    type = serialized.method || \"GET\";\n  }\n  switch (type) {\n    case \"JSON\": {\n      const json = JSON.stringify(serialized.values);\n      return fetch(serialized.action, {\n        method: serialized.method,\n        body: json,\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"Accept\": \"application/json\",\n        },\n      });\n    }\n    case \"GET\": {\n      const params = serialized.values ? toURLParams(serialized.values) : \"\";\n      const url = `${serialized.action}${params ? \"?\" + params : \"\"}`;\n      return fetch(url, {\n        method: serialized.method,\n        headers: {\n          \"Accept\": \"application/json\",\n        },\n      });\n    }\n  }\n  const enctype =\n    (serialized.enctype && serialized.enctype === \"multipart/form-data\")\n      ? \"multipart/form-data\"\n      : \"application/x-www-form-urlencoded\";\n  const body = serialized.values\n    ? enctype === \"multipart/form-data\"\n      ? serialized.values\n      : toURLParams(serialized.values)\n    : \"\";\n  return fetch(serialized.action, {\n    method: serialized.method,\n    body,\n    headers: {\n      \"Content-Type\": enctype,\n      \"Accept\": \"application/json\",\n    },\n  });\n};\n\ninterface EnhanceFormConfig {\n  method: AllowedMethodTypes;\n  classBusy: string | false;\n  doDisableForm: boolean;\n  doReEnableForm: boolean | number;\n  callback?: (error: Error | null, response: Response | null) => void;\n}\n\nconst defaultConfig: EnhanceFormConfig = {\n  method: \"AUTO\" as const,\n  classBusy: \"busy\",\n  doDisableForm: true,\n  doReEnableForm: true,\n};\n\n/**\n * Automatically fetches the form data when the form is submitted.\n * Optionally disables the form and adds a class to it while fetching.\n *\n * Reads the entire configuration for fetching from the form itself.\n *\n * Can take an old-school nodeback function, with the error as the first argument.\n * @param callback\n * @param config\n */\nexport const autoFetchWhenSubmit = (\n  config: Partial<EnhanceFormConfig> = defaultConfig,\n): (event: SubmitEvent | Event) => void => {\n  const { method, classBusy, doDisableForm, doReEnableForm, callback } = {\n    ...defaultConfig,\n    ...config,\n  };\n  const useSerializedData = (\n    serialized: SimpleSerializedForm,\n    form: HTMLFormElement,\n  ) => {\n    const promise = pickCorrectFetch(method, serialized);\n\n    doDisableForm && disableForm(form);\n    classBusy && form.classList.add(classBusy);\n\n    if (callback != null) {\n      promise\n        .then((response) => callback(null, response))\n        .catch((error) => callback(error, null));\n    }\n    promise.finally(() => {\n      if (doReEnableForm === true) {\n        enableForm(form);\n      } else if (typeof doReEnableForm === \"number\") {\n        setTimeout(() => enableForm(form), doReEnableForm);\n      }\n      classBusy && form.classList.remove(classBusy);\n    });\n    return promise;\n  };\n  return handleSimpleFormSubmit(useSerializedData);\n};\n", "const _classCache = new Set<string>();\nimport { ABORT } from \"../any/symbols.ts\";\n\ninterface ProcessDomElementOnceOptions {\n  /**\n   * the class name to add to each processed element. Defaults to a generated class name if none was provided.\n   */\n  className?: string;\n  /**\n   * the root element to query from. Defaults to `document`.\n   */\n  root?: HTMLElement;\n  /**\n   * If provided, this function is called when an error occurs during processing.\n   * Otherwise, errors are re-thrown.\n   * When handling an error,\n   * @param error the error that occurred during processing.\n   * @param ABORT - the ABORT symbol. If returned from the onError function, processing is aborted for all further elements.\n   */\n  onError?: (error: unknown, ABORT: ABORT) => ABORT | void;\n}\n\n/**\n * Safe function to attach behaviors to DOM elements, when you want to ensure the behavior is only applied once.\n * each element is ensured to be processed once through applying a gating class name.\n * Additionally to that specific class name, the class `isJSProcessed` is added to each processed element, which can be used to style elements in CSS.\n * @param selectors - The CSS selector for the elements to process.\n * @param functor - The function to apply to each element.\n * @param opts - Options\n */\nexport function processDomElementOnce<\n  K extends keyof HTMLElementTagNameMap,\n  E extends NodeListOf<HTMLElementTagNameMap[K]>\n>(\n  selectors: K,\n  functor: (element: E) => void,\n  opts?: ProcessDomElementOnceOptions\n): void;\nexport function processDomElementOnce<\n  K extends keyof SVGElementTagNameMap,\n  E extends NodeListOf<SVGElementTagNameMap[K]>\n>(\n  selectors: K,\n  functor: (element: E) => void,\n  opts?: ProcessDomElementOnceOptions\n): void;\nexport function processDomElementOnce<\n  K extends keyof MathMLElementTagNameMap,\n  E extends NodeListOf<MathMLElementTagNameMap[K]>\n>(\n  selectors: K,\n  functor: (element: E) => void,\n  opts?: ProcessDomElementOnceOptions\n): void;\nexport function processDomElementOnce<E extends HTMLElement>(\n  selectors: string,\n  functor: (element: E) => void,\n  opts?: ProcessDomElementOnceOptions\n): void;\nexport function processDomElementOnce<E extends HTMLElement>(\n  selectors: string,\n  functor: (element: E) => void,\n  opts?: ProcessDomElementOnceOptions\n) {\n  const { className, root = document, onError } = opts || {};\n  let addedClass =\n    className ||\n    `js-processed-${\n      functor.name ? functor.name : selectors.replaceAll(/[^a-zA-Z0-9]/g, \"-\")\n    }`;\n\n  let n = 1;\n  while (_classCache.has(addedClass) && n < 1000) {\n    // arbitrary limit to prevent infinite loop\n    addedClass = addedClass + n++;\n  }\n\n  _classCache.add(addedClass);\n\n  const elements = root.querySelectorAll<E>(selectors);\n  if (!elements || !elements.length) {\n    //console.warn(`didn't find any element for selector \"${selectors}\"`);\n    return;\n  }\n  elements.forEach((element) => {\n    if (!element.classList.contains(addedClass)) {\n      element.classList.add(\"isJSProcessed\", addedClass);\n      if (onError) {\n        try {\n          functor(element);\n        } catch (error) {\n          const result = onError(error, ABORT);\n          if (result === ABORT) {\n            return;\n          }\n        }\n      } else {\n        functor(element);\n      }\n    }\n  });\n}\n", "import type { GenericFunction } from \"../types/GenericFunction.ts\";\n\n/**\n * Calls a function when the user stops scrolling.\n * Cleans itself, so you need to call it every time (this isn't an event handler).\n * TODO: maybe use `onscrollend` instead, and provide a polyfill for Safari\n * @param fn - The function to call when the user stops scrolling.\n * @param checkInterval - The interval in milliseconds to check if the user has stopped scrolling.\n * @param root - The root element to listen for scroll events on. Defaults to the global window object.\n */\nexport const onScrollStopped = (\n  fn: GenericFunction,\n  checkInterval = 150,\n  root?: Node,\n): void => {\n  let timer = -1;\n  const target = root ?? globalThis;\n  const onScroll = () => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn();\n      target.removeEventListener(\"scroll\", onScroll);\n    }, checkInterval);\n  };\n  target.addEventListener(\"scroll\", onScroll, { passive: true });\n};\n", "/**\n * Cleans up a URL string by removing leading and trailing slashes and replacing multiple consecutive slashes with a single slash.\n *\n * @param path - The URL string to be cleaned up.\n * @returns The cleaned up URL string.\n */\nexport const cleanupUrlString = (path: string) =>\n  path.replace(/^\\/|\\/$/g, \"\").replace(/\\/+/g, \"/\");\n", "import { cleanupUrlString } from \"../../toolbox/any/cleanupUrlString.ts\";\n\nexport const API = (base = \"https://api.gdquest.com/1\") => ({\n  claps: {\n    async add(amount: number, url: string) {\n      const response = await fetch(\n        `${base}/claps/add/${amount}/${cleanupUrlString(url)}`,\n      );\n      return await response.json();\n    },\n    async get(url: string): Promise<number> {\n      const response = await fetch(\n        `${base}/claps/get/${cleanupUrlString(url)}`,\n      );\n      const data = await response.json();\n      if (typeof data !== \"number\") {\n        if (\"message\" in data && data.message) {\n          throw new Error(data.message);\n        }\n        throw new Error(\n          \"Invalid response from claps API \" + JSON.stringify(data),\n        );\n      }\n      return data;\n    },\n  },\n  newsletter: {\n    async subscribe(email: string, name: string) {\n      const formData = new FormData();\n      formData.append(\"email\", email);\n      formData.append(\"name\", name);\n      formData.append(\"json\", \"true\");\n      const response = await fetch(\n        `${base}/newsletter`,\n        {\n          method: \"POST\",\n          body: formData,\n        },\n      );\n      return await response.json();\n    },\n  },\n});\n", "const env = {\n  API_URL: Deno.env.get(\"API_URL\")!,\n};\n\nObject.entries(env).forEach(([key, value]) => {\n  if (!value) {\n    throw new Error(`\\`${key}\\` is not defined`);\n  }\n});\n\nexport const { API_URL } = env;\n", "export interface DomRelativePosition {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n  width: number;\n  height: number;\n  parentHeight: number;\n  parentWidth: number;\n}\n/**\n * Checks if an element is at least partially visible within its scrollable parent\n * @param element - The element to check visibility for\n * @param scrollableParent - The scrollable container element\n * @returns `true` if the element is at least partially visible\n */\nexport const getElementRelativePosition = (\n  element: HTMLElement,\n  scrollableParent: HTMLElement,\n): DomRelativePosition => {\n  const parentRect = scrollableParent.getBoundingClientRect();\n  const elementRect = element.getBoundingClientRect();\n\n  const relativeDimensions: DomRelativePosition = {\n    top: elementRect.top - parentRect.top,\n    left: elementRect.left - parentRect.left,\n    right: elementRect.right - parentRect.left,\n    bottom: elementRect.bottom - parentRect.top,\n    width: elementRect.width,\n    height: elementRect.height,\n    parentHeight: parentRect.height,\n    parentWidth: parentRect.width,\n  };\n\n  return relativeDimensions;\n};\n", "import {\n  type DomRelativePosition,\n  getElementRelativePosition,\n} from \"./getElementRelativePosition.ts\";\n/**\n * Checks if an element is at least partially visible within its scrollable parent\n * @param element - The element to check visibility for\n * @param scrollableParent - The scrollable container element\n * @returns `true` if the element is at least partially visible\n */\nexport const isElementPartiallyVisibleInParent = (\n  element: HTMLElement,\n  scrollableParent: HTMLElement,\n): boolean => {\n  const relative = getElementRelativePosition(element, scrollableParent);\n\n  return isRelativePositionPartiallyWithinParent(relative);\n};\n\nexport const isRelativePositionPartiallyWithinParent = (\n  relative: DomRelativePosition,\n): boolean => (relative.bottom > 0 &&\n  relative.bottom < relative.parentHeight);\n", "import { getElementRelativePosition } from \"./getElementRelativePosition.ts\";\nimport { isRelativePositionPartiallyWithinParent } from \"./isElementPartiallyVisibleInParent.ts\";\n\n/**\n * Scrolls element into view only if it's not already visible\n * @param element - Element to scroll into view\n * @param scrollableParent - Scrollable parent container\n * @returns true if element was scrolled into view, false otherwise\n */\nexport const scrollIntoViewIfPartiallyVisible = (\n  element: HTMLElement,\n  scrollableParent: HTMLElement,\n): boolean => {\n  const relative = getElementRelativePosition(element, scrollableParent);\n  const isPartiallyVisible = isRelativePositionPartiallyWithinParent(relative);\n\n  if (isPartiallyVisible) {\n    return false;\n  }\n\n  if (relative.top < 0) {\n    // Scroll element to top if requested or if element is above viewport\n    scrollableParent.scrollTop += relative.top;\n  } else {\n    // Scroll element to bottom if it's below viewport\n    scrollableParent.scrollTop += relative.top - relative.parentHeight +\n      relative.height;\n  }\n  return true;\n};\n", "import type { Signal } from \"../any/Signal.ts\";\nimport type { WritableKeysOf } from \"type-fest\";\n\ntype Attribute = WritableKeysOf<Element>;\nexport interface NodeSignalBindedFunction {\n  (node: Text, attributeName?: \"textContent\"): Text;\n  <T extends HTMLElement>(node: T, attributeName?: Attribute): T;\n  <T extends Text | HTMLElement>(node: T, attributeName?: Attribute): T;\n  __bind: true; // TODO: why did I add this?\n}\n\n/**\n * Creates a function that binds a signal to a node's attribute or text content.\n * @param signal - The signal to bind.\n * @param mapper - A function that converts the signal value to a string.\n * @returns A function that binds the signal to a node's attribute or text content.\n */\nexport const makeNodeSignalBinder = <\n  SignalType,\n  SignalInput,\n  NodeType extends Text | HTMLElement,\n>(\n  signal: Signal<SignalType, SignalInput>,\n  node: NodeType,\n  mapper: (node: NodeType, val: SignalType) => void,\n): NodeType => {\n  mapper(node, signal.get());\n  signal.on((v) => {\n    mapper(node, v);\n  });\n  return node;\n};\n", "/**\n * Returns a function that waits for a number of milliseconds. Suitable to be used\n * in a promise chain.\n * @see [delay]({@link ./delay.ts})\n */\nexport const wait = (milliseconds: number) => <T = undefined>(value?: T) =>\n  new Promise((resolve) => setTimeout(() => resolve(value as T), milliseconds));\n", "/**\n * Utility: use it at the end of switch statements to make sure all matches are covered.\n * Only useful in an editor that supports JSDOC strong typing.\n *\n * Use it like so\n * ```js\n * switch(data):\n *  case A:\n *    doThing();\n *    break;\n *  case B:\n *    doOtherThing();\n *    break;\n *  default:\n *    throw new UnreachableCaseError(state);\n * ```\n * It `data` may be more options, then `state` will be underlined with the error\n * ```\n * Argument of type 'T' is not assignable to parameter of type 'never'\n * ```\n * Where `T` is the type of `data`.\n * To remove the error, handle all cases.\n */\nexport class UnreachableCaseError extends Error {\n  constructor(value: never) {\n    super(`Unreachable case: ${JSON.stringify(value)}`);\n  }\n}\n\n/**\n * Utility: use it at the end of switch statements to make sure all matches are covered.\n * Only useful in an editor that supports JSDOC strong typing.\n *\n * Use it like so\n * ```js\n * switch(data):\n *  case A:\n *    doThing();\n *    break;\n *  case B:\n *    doOtherThing();\n *    break;\n *  default:\n *    assertExhaustiveSwitch(state);\n * ```\n * It `data` may be more options, then `assertExhaustiveSwitch` will be underlined with the error\n * ```\n * Argument of type 'T' is not assignable to parameter of type 'never'\n * ```\n * Where `T` is the type of `data`.\n * To remove the error, handle all cases.\n */\nexport const assertExhaustiveSwitch = (_: never): never => {\n  throw new UnreachableCaseError(_);\n};\n", "/**\n * Transforms any input into an `Error` instance.\n * This is useful for ensuring that any error handling code receives an `Error` object.\n */\nexport const ensureError = <T extends unknown>(error: T): Error => {\n  if (error instanceof Error) {\n    return error;\n  }\n  if (typeof error === \"string\") {\n    return new Error(error);\n  }\n\n  if (typeof error === \"object\" && error !== null) {\n    try {\n      return new Error(JSON.stringify(error));\n    } catch (e) {\n      return new Error(\"An error occurred, but it could not be serialized\");\n    }\n  }\n  return new Error(\"An unknown error occurred\");\n};\n", "import { Signal } from \"./Signal.ts\";\nimport { assertExhaustiveSwitch } from \"./UnreachableCaseError.ts\";\nimport { ensureError } from \"./ensureError.ts\";\n\ninterface ResultSuccess<T> {\n  data: T;\n  error: null;\n  success: true;\n  status: \"success\";\n}\n\ninterface ResultError {\n  data: null;\n  error: Error;\n  success: false;\n  status: \"error\";\n}\n\ninterface ResultLoading {\n  data: null;\n  error: null;\n  success: false;\n  status: \"loading\";\n}\n\ninterface ResultNone {\n  data: null;\n  error: null;\n  success: false;\n  status: \"none\";\n}\n\ntype Result<T> = ResultSuccess<T> | ResultError | ResultLoading | ResultNone;\n\ninterface FetcherSignal<T> extends Signal<Result<T>, Result<T>> {\n  /**\n   * Loads data from the given URL and updates the signal state.\n   * If a request is already in progress or data is already loaded, it will not initiate a new request.\n   * Use `reset()` to clear the current state before loading new data.\n   *\n   * @param url - The URL to fetch data from.\n   */\n  load: (url: string) => void;\n  /**\n   * Resets the signal state to its initial value.\n   */\n  reset: () => FetcherSignal<T>;\n  /**\n   * Returns the current data from the signal.\n   * If the signal is in a \"none\" state, it will return `null`.\n   */\n  data: () => T | null;\n}\n\n/**\n * @param initialValue - Optional initial value to set the signal state.\n * If provided, the signal will start in a success state with the given data.\n * If not provided, the signal will start in a \"none\" state. If you want to load data after providing an initial value, use `reset()` before `load()`.\n * @returns\n */\nexport const FetcherSignal = <T>(initialValue?: T): FetcherSignal<T> => {\n  const signal = Signal<Result<T>>(\n    initialValue\n      ? {\n        data: initialValue,\n        error: null,\n        success: true,\n        status: \"success\",\n      }\n      : {\n        data: null,\n        error: null,\n        success: false,\n        status: \"none\",\n      },\n  );\n\n  const load = (url: string) => {\n    const currentStatus = signal.get().status;\n\n    if (currentStatus !== \"none\") {\n      switch (currentStatus) {\n        case \"loading\":\n          console.warn(\"Already loading data, ignoring new request.\");\n          break;\n        case \"success\":\n        case \"error\":\n          console.warn(\"Data already loaded, ignoring new request.\");\n          break;\n        default:\n          assertExhaustiveSwitch(currentStatus);\n      }\n      return;\n    }\n\n    signal.set({\n      data: null,\n      error: null,\n      success: false,\n      status: \"loading\",\n    });\n\n    fetch(url)\n      .then((response) => {\n        if (!response.ok) {\n          throw new Error(`Failed to fetch ${url}`);\n        }\n        return response.json();\n      })\n      .then((data: T) => {\n        signal.set({\n          data,\n          error: null,\n          success: true,\n          status: \"success\",\n        });\n      })\n      .catch((error) => {\n        signal.set({\n          data: null,\n          error: ensureError(error),\n          success: false,\n          status: \"error\",\n        });\n      });\n  };\n\n  const reset = () => {\n    signal.set({\n      data: null,\n      error: null,\n      success: false,\n      status: \"none\",\n    });\n    return fetcherSignal;\n  };\n\n  const data = () => signal.get().data;\n\n  const fetcherSignal = {\n    ...signal,\n    load,\n    reset,\n    data,\n  };\n\n  return fetcherSignal;\n};\n", "/**\n * Fisher-Yates algorithm shuffle\n * @param input - The array to shuffle.\n * @returns\n */\nexport const shuffleArray = <T>([...arr]: T[]): T[] => {\n  let m = arr.length;\n  while (m) {\n    const i = Math.floor(Math.random() * m--);\n    [arr[m], arr[i]] = [arr[i], arr[m]];\n  }\n  return arr;\n};\n", "interface SearchParamsToObjOptsBase {\n  /**\n   * Only used if `single` is `true`. Joins arrays with this character;\n   * Set to `false` to return the first value instead of joining.\n   * Defaults to space `\" \"`.\n   */\n  joinArrayChar?: false | string;\n}\n\ninterface SearchParamsToObjOptsSingle extends SearchParamsToObjOptsBase {\n  /**\n   * If true, the function will return an object with all values as strings.\n   * If false, the function will return an object with all values as arrays of strings.\n   * @default false\n   */\n  single: true;\n}\n\ninterface SearchParamsToObjOptsArray extends SearchParamsToObjOptsBase {\n  /**\n   * If true, the function will return an object with all values as strings.\n   * If false, the function will return an object with all values as arrays of strings.\n   * @default false\n   */\n  single?: false | undefined;\n}\n\ntype SearchParamsToObjOpts =\n  | SearchParamsToObjOptsSingle\n  | SearchParamsToObjOptsArray;\n\n/**\n * Converts a URLSearchParams object or a query string into a plain object.\n * @param search The URLSearchParams object or query string to convert.\n * @param opts Options for controlling the conversion behavior.\n * @returns A plain object representation of the search parameters.\n */\nexport function searchParamsToObj(\n  search: string | URLSearchParams,\n  opts: SearchParamsToObjOptsSingle,\n): Record<string, string>;\nexport function searchParamsToObj(\n  search: string | URLSearchParams,\n  opts?: SearchParamsToObjOptsArray,\n): Record<string, string[]>;\nexport function searchParamsToObj(\n  search: string | URLSearchParams,\n  { single = false, joinArrayChar = \" \" }: SearchParamsToObjOpts = {},\n): Record<string, string> | Record<string, string[]> {\n  search = search instanceof URLSearchParams\n    ? search\n    : new URLSearchParams(search);\n  const result: Record<string, string[]> = {};\n  search.forEach((value, key) => {\n    result[key] = result[key] || [];\n    result[key].push(value);\n  });\n  if (single) {\n    const singleResult: Record<string, string> = {};\n    for (const key in result) {\n      singleResult[key] = joinArrayChar\n        ? result[key].join(joinArrayChar)\n        : result[key][0];\n    }\n    return singleResult;\n  }\n  return result;\n}\n", "import type { Simplify } from \"../../type-fest/src/source/simplify.ts\";\n/**\n * Returns a new object containing all specified keys from the original object.\n * If the original object doesn't contain all keys, the missing keys will be set to undefined.\n * **warning**: For convenience, the type _does not_ include the possible `undefined` value;\n * All values are assumed to be found; it is implied that you know for sure they exist, or\n * you'll otherwise check.\n * @param obj The original object\n * @param keys The keys to pick from the original object\n * @returns A new object containing all specified keys\n */\nexport const pickAll = <T extends Record<K, unknown>, K extends keyof T>(\n  obj: T,\n  keys: readonly K[],\n): Simplify<Pick<T, K>> => {\n  return keys.reduce((acc, val) => {\n    return (acc[val] = obj[val]), acc;\n  }, {} as Simplify<Pick<T, K>>);\n};\n\n/**\n * Returns an object containing only the specified keys from the original object.\n * If the passed object contains only part of the keys, only these will be included.\n * If you want to ensure that all keys are present in the returned object, use {@link pickAll}.\n * If you want an error if a key doesn't exist, use Zod.\n * @param obj The original object\n * @param keys The keys to pick from the original object\n * @returns A new object containing only the specified keys\n */\nexport const pick = <T extends Record<K, unknown>, K extends keyof T>(\n  obj: T,\n  keys: readonly K[],\n): Simplify<Partial<Pick<T, K>>> => {\n  return keys.reduce((acc, val) => {\n    if (val in obj) {\n      acc[val] = obj[val];\n    }\n    return acc;\n  }, {} as Simplify<Partial<Pick<T, K>>>);\n};\n", "interface QuerySelectorOptions {\n  /**\n   * The parent element to search within. Defaults to the document. If explicit `null` is passed, the function\n   * is short-circuited to return `null` immediately.\n   */\n  parent?: Element | Document | null;\n  /** Callback invoked when no element is found. Defaults to `console.warn`. Set it to `false` to disable the warning. */\n  onNotFound?:\n    | ((selector: string, parent: Element | Document | null) => void)\n    | false;\n}\n\n/**\n * Thin wrapper around `Element.querySelector` with added features.\n * Queries the DOM for a single element matching the given selector.\n *\n * **Note**: This function assumes the element is of type `HTMLElement` when not specified.\n * The original `querySelector` can return regular `Element` nodes;\n * this function can too, but makes an assumption that's convenient, even if it reduces\n * type safety.\n * @param selector The CSS selector to match.\n * @param options Optional parameters for the query.\n * @returns The first matching element, or null if no match is found.\n */\nexport function querySelector<K extends keyof HTMLElementTagNameMap>(\n  selectors: K,\n  options?: QuerySelectorOptions\n): HTMLElementTagNameMap[K] | null;\nexport function querySelector<K extends keyof SVGElementTagNameMap>(\n  selectors: K,\n  options?: QuerySelectorOptions\n): SVGElementTagNameMap[K] | null;\nexport function querySelector<K extends keyof MathMLElementTagNameMap>(\n  selectors: K,\n  options?: QuerySelectorOptions\n): MathMLElementTagNameMap[K] | null;\nexport function querySelector<E extends HTMLElement = HTMLElement>(\n  selectors: string,\n  options?: QuerySelectorOptions\n): E | null;\nexport function querySelector<E extends HTMLElement>(\n  selector: string,\n  options?: QuerySelectorOptions\n): E | null {\n  const parent = options?.parent === null ? null : options?.parent ?? document;\n  const element =\n    parent === null ? null : (parent.querySelector(selector) as E | null);\n  if (element === null) {\n    if (options?.onNotFound) {\n      options.onNotFound(selector, parent);\n    } else if (options?.onNotFound !== false) {\n      console.warn(`Element not found: \\`${selector}\\` in`, parent);\n    }\n  }\n  return element;\n}\n", "interface QuerySelectorAllOptions {\n  /**\n   * The parent element to search within. Defaults to the document. If explicit `null` is passed, the function\n   * is short-circuited to return `null` immediately.\n   */\n  parent?: Element | Document | null;\n  /** Callback invoked when no element is found. Defaults to `console.warn`. Set it to `false` to disable the warning. */\n  onNotFound?:\n    | ((selector: string, parent: Element | Document | null) => void)\n    | false;\n}\n\n/**\n * Thin wrapper around `Element.querySelectorAll` with added features.\n * Queries the DOM for all elements matching the given selector.\n *\n * **Note**: This function assumes the element is of type `HTMLElement` when not specified.\n * The original `querySelector` can return regular `Element` nodes;\n * this function can too, but makes an assumption that's convenient, even if it reduces\n * type safety.\n *\n * **Note 2**: Unlike `querySelector`, this function returns:\n * - `null` if no elements are found\n * - an array of elements and **not** a `NodeListOf<Element>`.\n *\n * Mind those differences.\n * @param selector The CSS selector to match.\n * @param options Optional parameters for the query.\n * @returns An array of matching elements, or `null` if no matches are found.\n */\nexport function querySelectorAll<K extends keyof HTMLElementTagNameMap>(\n  selectors: K,\n  options?: QuerySelectorAllOptions\n): HTMLElementTagNameMap[K][];\nexport function querySelectorAll<K extends keyof SVGElementTagNameMap>(\n  selectors: K,\n  options?: QuerySelectorAllOptions\n): SVGElementTagNameMap[K][];\nexport function querySelectorAll<K extends keyof MathMLElementTagNameMap>(\n  selectors: K,\n  options?: QuerySelectorAllOptions\n): MathMLElementTagNameMap[K][];\nexport function querySelectorAll<E extends HTMLElement = HTMLElement>(\n  selectors: string,\n  options?: QuerySelectorAllOptions\n): E[];\nexport function querySelectorAll<E extends HTMLElement = HTMLElement>(\n  selector: string,\n  options?: QuerySelectorAllOptions\n): E[] | null {\n  const parent = options?.parent === null ? null : options?.parent ?? document;\n  const elements =\n    parent === null ? [] : (parent.querySelectorAll(selector) as NodeListOf<E>);\n  if (elements.length === 0) {\n    if (options?.onNotFound) {\n      options.onNotFound(selector, parent);\n    } else if (options?.onNotFound !== false) {\n      console.warn(\n        `Didn't find any element for selector \\`${selector}\\` in`,\n        parent\n      );\n    }\n    return null;\n  }\n  return Array.from(elements);\n}\n", "export const isNotNull = <T>(obj: T | null | undefined): obj is T =>\n  obj != null;\n", "import { isNotNull } from \"./isNotNull.ts\";\n\nexport const ensureAllElementsNotNull = <\n  T extends readonly (unknown | null | undefined)[],\n>(\n  ...arr: T\n): { [K in keyof T]: NonNullable<T[K]> } | null =>\n  arr.every(isNotNull)\n    ? arr as unknown as { [K in keyof T]: NonNullable<T[K]> }\n    : null;\n", "export class DataBearingError<T = unknown> extends Error {\n  constructor(public data: T, message: string) {\n    super(message);\n    this.name = \"DataBearingError\";\n  }\n}\n", "export const prefersReducedMotion = () =>\n  globalThis.matchMedia(`(prefers-reduced-motion: reduce)`) != null &&\n  globalThis.matchMedia(`(prefers-reduced-motion: reduce)`).matches === true;\n", "/**\n * Import necessary dependencies from the toolbox.\n * Deno's bundle tree shaking seems to include everything, including unused imports.\n * More than a weight problem, it also tries to import `fs` and other Node.js modules,\n * which breaks the script in the browser.\n */\n\nimport { simpleModuleLogger } from \"../../toolbox/any/simpleModuleLogger.ts\";\nexport const makeLogger = simpleModuleLogger();\n\nexport { h } from \"../../toolbox/any/createElement/h.web.ts\";\nexport { debounce } from \"../../toolbox/any/debounce.ts\";\nexport { getClampedRandomInt } from \"../../toolbox/any/getClampedRandomInt.ts\";\nexport { splitPathStringToParts } from \"../../toolbox/any/splitPathStringToParts.ts\";\nexport { Signal } from \"../../toolbox/any/Signal.ts\";\nexport { type Json } from \"../../toolbox/supabase/database-generated.ts\";\nexport {\n  userMessagesCollection,\n  type UserMessageType,\n} from \"../../toolbox/web/userMessagesCollection.ts\";\nexport { autoFetchWhenSubmit } from \"../../toolbox/web/autoFetchWhenSubmit.ts\";\nexport { processDomElementOnce } from \"../../toolbox/web/processDomElementOnce.ts\";\nexport { onScrollStopped } from \"../../toolbox/web/onScrollStopped.ts\";\nexport { cleanupUrlString } from \"../../toolbox/any/cleanupUrlString.ts\";\nimport { API } from \"./api.ts\";\nimport { API_URL } from \"./env.ts\";\nexport { type MailSubscriptionRequestFormResponse } from \"../../toolbox/mail/parseSubscriptionRequest.ts\";\nexport { scrollIntoViewIfPartiallyVisible } from \"../../toolbox/web/scrollIntoViewIfPartiallyVisible.ts\";\nexport { makeNodeSignalBinder } from \"../../toolbox/web/makeNodeSignalBinder.ts\";\nexport { wait } from \"../../toolbox/any/wait.ts\";\nexport { FetcherSignal } from \"../../toolbox/any/FetcherSignal.ts\";\nexport { shuffleArray } from \"../../toolbox/any/shuffleArray.ts\";\nexport { searchParamsToObj } from \"../../toolbox/any/searchParamsToObj.ts\";\nexport { pick } from \"../../toolbox/any/pick.ts\";\nexport type {\n  SearchableItem,\n  SearchableItemKeys,\n} from \"../../toolbox/content/item/03_resolved.ts\";\nexport type { AdvancedMechanicsNodeInput } from \"../../toolbox/content/advancedMechanicsNode/01_input.ts\";\nexport type { GlossaryDictionaryKeys } from \"../../toolbox/content/glossaryEntry/getGlossaryDictionary.ts\";\nexport { querySelector } from \"../../toolbox/web/querySelector.ts\";\nexport { querySelectorAll } from \"../../toolbox/web/querySelectorAll.ts\";\nexport { ensureAllElementsNotNull } from \"../../toolbox/any/ensureAllElementsNotNull.ts\";\nexport { getInputLabelTextContent } from \"./../../toolbox/web/getInputLabelTextContent.ts\";\nexport { DataBearingError } from \"../../toolbox/any/DataBearingError.ts\";\nexport { prefersReducedMotion } from \"../../toolbox/web/prefersReducedMotion.ts\";\nexport const api = API(API_URL);\n", "import {\n  h,\n  processDomElementOnce,\n} from \"../clientScript/clientDependencies.ts\";\n\nconst { button } = h;\n\nexport class ToggleShowEvent extends Event {\n  public readonly isHidden: boolean;\n  constructor(\n    public readonly isShown: boolean,\n    public readonly controls: HTMLElement,\n    eventInitDict?: EventInit,\n  ) {\n    super(\"toggler-toggleshow\", eventInitDict);\n    this.controls = controls;\n    this.isHidden = !isShown;\n  }\n}\n\ndeclare global {\n  interface GlobalEventHandlersEventMap {\n    \"toggler-toggleshow\": ToggleShowEvent;\n  }\n}\n\nfunction toggleButton(this: HTMLButtonElement) {\n  const expanded = this.getAttribute(\"aria-expanded\") === \"true\";\n  this.setAttribute(\"aria-expanded\", expanded ? \"false\" : \"true\");\n  const targetElementID = this.getAttribute(\"aria-controls\");\n  const targetElement = targetElementID\n    ? document.getElementById(targetElementID)\n    : null;\n  if (!targetElement) {\n    return;\n  }\n  const targetToggledClassName = this.dataset[\"toggledClass\"];\n  if (targetToggledClassName) {\n    if (expanded) {\n      targetElement.classList.remove(targetToggledClassName);\n    } else {\n      targetElement.classList.add(targetToggledClassName);\n    }\n    const event = new ToggleShowEvent(!expanded, targetElement);\n    this.dispatchEvent(event);\n  }\n  const bodyClassName = this.dataset[\"bodyClass\"];\n  if (bodyClassName) {\n    if (expanded) {\n      document.body.classList.remove(bodyClassName);\n    } else {\n      document.body.classList.add(bodyClassName);\n    }\n  }\n}\n\nexport const processTogglerButton = (button: HTMLButtonElement) => {\n  if (\n    !button ||\n    !(button.tagName === \"BUTTON\")\n  ) {\n    return;\n  }\n  if (!button.dataset[\"toggledClass\"]) {\n    button.dataset[\"toggledClass\"] = \"isToggled\";\n  }\n  button.addEventListener(\"click\", toggleButton);\n  if (\n    button.dataset[\"startExpanded\"] != null &&\n    (button.dataset[\"startExpanded\"] !== button.getAttribute(\"aria-expanded\"))\n  ) {\n    button.click();\n  }\n};\n\nprocessDomElementOnce(\"button[data-is='toggler-button']\", processTogglerButton);\n\nexport const TogglerButton = (\n  props: { ariaControls: string } & Record<string, unknown>,\n  ...children: Element[]\n) => {\n  const toggleButton = button(\n    {\n      ariaExpanded: \"false\",\n      ariaLabel: \"Toggle content\",\n      dataIs: \"toggler-button\",\n      ...props,\n    },\n    ...children,\n  );\n  processTogglerButton(toggleButton);\n  return toggleButton;\n};\n", "import { processDomElementOnce } from \"../clientScript/clientDependencies.ts\";\n\nconst classPrefix = \".betaMention\";\n\nprocessDomElementOnce(classPrefix, (element: HTMLElement) => {\n  const button = element.querySelector(\"button\");\n  const message = element.querySelector(\"p\");\n\n  if (button && message) {\n    button.addEventListener(\"click\", () => {\n      element.classList.toggle(\"closed\");\n      localStorage.setItem(\n        \"betaMentionClosed\",\n        element.classList.contains(\"closed\") ? \"true\" : \"false\"\n      );\n    });\n  }\n\n  // On load, check if the mention was closed before\n  const wasClosed = localStorage.getItem(\"betaMentionClosed\");\n  if (wasClosed === \"true\") {\n    element.classList.add(\"closed\");\n  }\n});\n", "import {\n  debounce,\n  ensureAllElementsNotNull,\n  prefersReducedMotion,\n  processDomElementOnce,\n  querySelector,\n  querySelectorAll,\n} from \"../clientScript/clientDependencies.ts\";\n\nconst timerTime = 8000;\n\nfunction setCurrent(this: HTMLElement, isCurrent: boolean) {\n  if (isCurrent) {\n    this.setAttribute(\"aria-current\", \"true\");\n    this.setAttribute(\"aria-disabled\", \"true\");\n    this.setAttribute(\"disabled\", \"true\");\n  } else {\n    this.removeAttribute(\"aria-current\");\n    this.removeAttribute(\"aria-disabled\");\n    this.removeAttribute(\"disabled\");\n  }\n}\ntype SetCurrent = typeof setCurrent;\n\nprocessDomElementOnce(\"carousel-wrapper\", (carouselWrapper) => {\n  const elements = ensureAllElementsNotNull(\n    querySelector<HTMLUListElement>(\".controls\", { parent: carouselWrapper }),\n    querySelectorAll<HTMLButtonElement & { setCurrent: SetCurrent }>(\"button\", {\n      parent: querySelector(\".navigation\", { parent: carouselWrapper }),\n    }),\n    querySelector<HTMLUListElement>(\".slidesList\"),\n    querySelector<HTMLDivElement>(\"live-region\", { parent: carouselWrapper }),\n  );\n  if (elements === null) {\n    console.error(\"Carousel: Missing control elements\");\n    return;\n  }\n  const [playControlsContainer, navigationDotsRaw, slider, liveRegion] =\n    elements;\n\n  const subElements = ensureAllElementsNotNull(\n    querySelector<HTMLButtonElement>(\"button.previous\", {\n      parent: playControlsContainer,\n    }),\n    querySelector<HTMLButtonElement>(\"button.next\", {\n      parent: playControlsContainer,\n    }),\n    querySelector<HTMLInputElement>(\"input[type='checkbox']\", {\n      parent: playControlsContainer,\n    }),\n    querySelector<HTMLLabelElement>(\"label\", { parent: playControlsContainer }),\n    querySelectorAll<HTMLLIElement>(\"li\", { parent: slider }),\n  );\n\n  if (subElements === null) {\n    console.error(\"Carousel: Missing play control elements\");\n    return;\n  }\n\n  const slideButtons = navigationDotsRaw.map((btn) => {\n    btn.setCurrent = setCurrent;\n    const targetIndex = parseInt(btn.dataset.for || \"\", 10);\n    if (isNaN(targetIndex)) {\n      console.warn(`Carousel: Missing target slide for button`, btn);\n      return btn;\n    }\n    btn.addEventListener(\"click\", () => {\n      controller.updateSlider(targetIndex);\n      if (!pauseRequested) {\n        startTimer();\n      }\n    });\n    return btn;\n  });\n\n  const [previousButton, nextButton, pauseInput, pauseLabel, slides] =\n    subElements;\n\n  const controller = (() => {\n    let currentSlide = Math.ceil(slider.scrollLeft / slider.offsetWidth) %\n      slides.length;\n\n    const nextSlide = () => updateSlider((currentSlide + 1) % slides.length);\n\n    const prevSlide = () =>\n      updateSlider((currentSlide - 1 + slides.length) % slides.length);\n\n    const updateSlider = (nextSlide: number) => {\n      if (nextSlide === currentSlide) {\n        return;\n      }\n      slideButtons.forEach((btn, index) => btn.setCurrent(index === nextSlide));\n      currentSlide = nextSlide;\n      slider.scrollLeft = slider.offsetWidth * currentSlide;\n      if (liveRegion) {\n        liveRegion.textContent = `Item ${currentSlide + 1} of ${slides.length}`;\n      }\n    };\n\n    return {\n      nextSlide,\n      prevSlide,\n      updateSlider,\n      get currentSlide() {\n        return currentSlide;\n      },\n    };\n  })();\n\n  let pauseInterval: number | null = null;\n  let pauseRequested = false;\n\n  const startTimer = () => {\n    clearInterval(pauseInterval as number);\n    if (pauseRequested) {\n      return;\n    }\n    pauseInterval = setInterval(controller.nextSlide, timerTime);\n    carouselWrapper.style.setProperty(\"--timer-animation-name\", \"none\");\n    carouselWrapper.style.setProperty(\"--timer-time\", `${timerTime}ms`);\n    // The animation would not be restarted on mobile when clicking around and\n    // updating the CSS, and you'd get the light purple progress animation\n    // getting out of sync with the carousel. This is used to force restart the\n    // animation\n    void carouselWrapper.offsetWidth;\n    carouselWrapper.style.setProperty(\n      \"--timer-animation-name\",\n      \"carouselProgressAnimation\",\n    );\n    if (pauseInput) {\n      pauseInput.checked = false;\n    }\n  };\n\n  const stopTimer = () => {\n    carouselWrapper.style.setProperty(\"--timer-time\", \"0ms\");\n    carouselWrapper.style.setProperty(\"--timer-animation-name\", \"none\");\n    clearInterval(pauseInterval as number);\n    pauseInterval = null;\n    if (pauseInput) {\n      pauseInput.checked = true;\n    }\n  };\n\n  previousButton.addEventListener(\"click\", () => {\n    controller.prevSlide();\n    if (!pauseRequested) {\n      startTimer();\n    }\n  });\n  nextButton.addEventListener(\"click\", () => {\n    controller.nextSlide();\n    if (!pauseRequested) {\n      startTimer();\n    }\n  });\n  slider.addEventListener(\n    \"scroll\",\n    debounce(() => {\n      const newSlide = Math.round(slider.scrollLeft / slider.offsetWidth);\n      if (newSlide !== controller.currentSlide) {\n        controller.updateSlider(newSlide);\n        if (!pauseRequested) {\n          startTimer();\n        }\n      }\n    }, 100),\n  );\n\n  if (prefersReducedMotion()) {\n    pauseLabel.remove();\n    pauseInput.remove();\n  } else {\n    pauseInput.addEventListener(\"change\", () => {\n      if (!pauseRequested) {\n        pauseRequested = true;\n        stopTimer();\n      } else {\n        pauseRequested = false;\n        startTimer();\n      }\n    });\n\n    startTimer();\n    if (pauseInput) {\n      pauseInput.checked = false;\n    }\n  }\n});\n", "import {\n  getClampedRandomInt,\n  h,\n  makeNodeSignalBinder,\n  Signal,\n  wait,\n} from \"../clientScript/clientDependencies.ts\";\nimport { createConfetti } from \"./clapsButton.client.ts\";\n\nconst baseClass = \"clapsGame\";\nconst { button, span, div, add, h4 } = h;\n\nfunction dragElement(elmnt: HTMLElement) {\n  let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;\n  const draggable = elmnt.querySelector<HTMLElement>(\"[data-is-draghandle]\") ||\n    elmnt;\n\n  // otherwise, move the DIV from anywhere inside the DIV:\n  draggable.addEventListener(\"mousedown\", dragMouseDown);\n\n  function dragMouseDown(e: MouseEvent) {\n    e.preventDefault();\n    // get the mouse cursor position at startup:\n    pos3 = e.clientX;\n    pos4 = e.clientY;\n    document.onmouseup = closeDragElement;\n    // call a function whenever the cursor moves:\n    document.onmousemove = elementDrag;\n  }\n\n  function elementDrag(e: MouseEvent) {\n    e.preventDefault();\n    // calculate the new cursor position:\n    pos1 = pos3 - e.clientX;\n    pos2 = pos4 - e.clientY;\n    pos3 = e.clientX;\n    pos4 = e.clientY;\n    // set the element's new position:\n    elmnt.style.top = (elmnt.offsetTop - pos2) + \"px\";\n    elmnt.style.left = (elmnt.offsetLeft - pos1) + \"px\";\n  }\n\n  function closeDragElement() {\n    // stop moving when mouse button is released:\n    document.onmouseup = null;\n    document.onmousemove = null;\n  }\n\n  return elmnt;\n}\n\nconst _startGame = () => {\n  const claps = Signal(0);\n  const cursors = Signal(0);\n  const clapsPerClick = Signal(0);\n  const shown = Signal(false);\n\n  const upgradesAvailable = [\n    {\n      name: \"Cursors\",\n      description: \"clicks once per second\",\n      cost: 20,\n      className: \"cursor\",\n      signal: cursors,\n    },\n    {\n      name: \"Strength\",\n      description: \"Each click gives you more claps\",\n      cost: 100,\n      className: \"strength\",\n      signal: clapsPerClick,\n    },\n  ];\n\n  const mainButton = makeNodeSignalBinder(\n    claps,\n    button(\n      {\n        class: `${baseClass}ClapsButton`,\n        onclick: () => {\n          claps.set(claps.get() + 1);\n          mainButton.setAttribute(\"aria-pressed\", \"true\");\n          setTimeout(() => {\n            mainButton.removeAttribute(\"aria-pressed\");\n          }, 500);\n        },\n      },\n      makeNodeSignalBinder(claps, span(), (node, val) => {\n        node.textContent = `${val}`;\n      }),\n    ),\n    (node) => {\n      node.append(createConfetti());\n    },\n  );\n\n  const incrementLater = (delay: number) =>\n    wait(delay)().then(() => mainButton.click());\n\n  const makeCursor = (index: number) => {\n    const clicker = span({\n      class: `${baseClass}MainClicker`,\n      style: { \"--index\": index },\n    });\n\n    setInterval(() => {\n      clicker.style.setProperty(\"--offset\", \"0\");\n      wait(200)().then(() => {\n        const increment = 1 + clapsPerClick.get();\n        const promises = [];\n        for (let j = 0; j < increment; j++) {\n          const delay = getClampedRandomInt(100, 50);\n          promises.push(() => incrementLater(delay));\n        }\n        promises.reduce((acc: Promise<unknown>, promise) => {\n          return acc.then(promise);\n        }, Promise.resolve()).then(() => {\n          clicker.style.removeProperty(\"--offset\");\n        });\n      });\n    }, 3000 * (1 + index));\n\n    return clicker;\n  };\n\n  add(\n    document.body,\n    makeNodeSignalBinder(\n      shown,\n      dragElement(div(\n        { class: `${baseClass}Panel` },\n        h4(\n          { class: `${baseClass}Title`, dataIsDraghandle: true },\n          \"Claps Clicker\",\n        ),\n        div(\n          { class: `${baseClass}Body` },\n          div(\n            { class: `${baseClass}Main` },\n            makeNodeSignalBinder(\n              cursors,\n              div({ class: `${baseClass}MainClickersContainer` }),\n              (node, value) => {\n                const existingClickers = node.querySelectorAll(\n                  `.${baseClass}MainClicker`,\n                ).length || 0;\n                for (let i = existingClickers; i < value; i++) {\n                  add(node, makeCursor(i));\n                }\n                node.style.setProperty(\"--clickers\", value.toString());\n              },\n            ),\n            mainButton,\n          ),\n          div(\n            { class: `${baseClass}UpgradesContainer` },\n            ...upgradesAvailable.map((\n              { name, description, cost, className, signal },\n            ) =>\n              makeNodeSignalBinder(\n                claps,\n                button(\n                  {\n                    class: [\n                      `${baseClass}Upgrade`,\n                      `${baseClass}Upgrade-${className}`,\n                    ],\n                    title: description,\n                  },\n                  span({ class: `${baseClass}UpgradeName` }, name),\n                  span({ class: `${baseClass}UpgradeCost` }, cost),\n                ),\n                (node, val) => {\n                  node.disabled = val < cost;\n                  node.onclick = () => {\n                    claps.set(val - cost);\n                    signal.set(signal.get() + 1);\n                  };\n                },\n              )\n            ),\n          ),\n        ),\n        button({\n          class: `${baseClass}CloseButton`,\n          onclick: () => {\n            shown.set(false);\n          },\n        }, span(\"close panel\")),\n      )),\n      (node, value) => {\n        if (value) {\n          node.style.removeProperty(\"display\");\n        } else {\n          node.style.setProperty(\"display\", \"none\");\n        }\n      },\n    ),\n  );\n\n  return shown;\n};\n\nlet showGame: Signal<boolean, boolean> | null = null;\n\nexport const startGame = () => {\n  if (!showGame) {\n    showGame = _startGame();\n  }\n  showGame.set(true);\n};\n", "import {\n  api,\n  cleanupUrlString,\n  debounce,\n  getClampedRandomInt,\n  processDomElementOnce,\n  Signal,\n} from \"../clientScript/clientDependencies.ts\";\nimport { startGame } from \"./clapsGame.client.ts\";\n\ntype ClapButton = HTMLButtonElement & { label: Element };\n\nconst pathname = cleanupUrlString(\n  new URL(globalThis.location.href).pathname,\n);\n\nexport const createConfetti = () => {\n  const randomRotationAngle = getClampedRandomInt(360) + \"deg\";\n\n  const particlesContainer = document.createElement(\"span\");\n  particlesContainer.dataset.is = \"confetti\";\n  particlesContainer.addEventListener(\n    \"animationend\",\n    () => particlesContainer.remove(),\n  );\n  particlesContainer.style.transform = `rotate(${randomRotationAngle})`;\n\n  let children = getClampedRandomInt(10, 5);\n\n  particlesContainer.classList.add(`has-${children + 1}`);\n\n  while (children-- >= 0) {\n    const particle = document.createElement(\"span\");\n    particle.style.setProperty(\"--angle\", getClampedRandomInt(25) + \"deg\");\n    particle.style.setProperty(\n      \"--destination\",\n      getClampedRandomInt(55, 5) + \"px\",\n    );\n    particlesContainer.appendChild(particle);\n  }\n\n  return particlesContainer;\n};\n\nconst getClapsOrRandom = () =>\n  api.claps.get(pathname).then((amount) => amount).catch((e) => {\n    console.error(e);\n    return getClampedRandomInt(2000, 3000);\n  });\n\ngetClapsOrRandom().then(\n  (initialAmount: number) => {\n    const clapsOnPage = new Set<readonly [Element, Element, Element]>();\n\n    const initialFormattedAmount = formatNumber(initialAmount);\n    const maxClapsBeforeGameStarts = 20;\n    const claps = Signal(initialAmount);\n    const clapped = Signal(0);\n\n    clapped.on(\n      (amount: number) => {\n        if (amount > maxClapsBeforeGameStarts) {\n          startGame();\n        }\n      },\n    );\n\n    const setClapButtonAmount = (amount: number, formattedAmount: string) =>\n    (\n      [total, abbreviated, bubble]: readonly [Element, Element, Element],\n    ): void => {\n      total.textContent = `${amount}`;\n      abbreviated.textContent = formattedAmount;\n      bubble.textContent = clapped.get() > 0 ? `+${clapped.get()}` : \"\";\n    };\n\n    const setAmount = (amount: number): void => {\n      const formattedAmount = formatNumber(amount);\n      clapsOnPage.forEach(setClapButtonAmount(amount, formattedAmount));\n    };\n\n    function increase(this: ClapButton) {\n      this.setAttribute(\"aria-pressed\", \"true\");\n      clapped.set(clapped.get() + 1);\n      claps.set(claps.get() + 1);\n      this.label.appendChild(createConfetti());\n    }\n\n    function formatNumber(number = 0) {\n      return number.toLocaleString(\"en-US\", {\n        maximumFractionDigits: 2,\n        notation: \"compact\",\n        compactDisplay: \"short\",\n      });\n    }\n\n    processDomElementOnce(\"button.clapsButton\", (button: ClapButton) => {\n      const total = button.querySelector(\".clapsButtonAmountTotal\");\n      const abbreviated = button.querySelector(\".clapsButtonAmountAbbreviated\");\n      const bubble = button.querySelector(\".clapsButtonBubble\");\n      const label = button.querySelector(\".clapsButtonLabel\");\n\n      if (!total || !abbreviated || !bubble || !label) {\n        return;\n      }\n\n      abbreviated.removeAttribute(\"hidden\");\n\n      const cache = [total, abbreviated, bubble] as const;\n\n      clapsOnPage.add(cache);\n      setClapButtonAmount(initialAmount, initialFormattedAmount)(cache);\n\n      button.addEventListener(\n        \"animationend\",\n        (event) => {\n          if (event.animationName === \"clapTotal\") {\n            button.setAttribute(\"aria-pressed\", \"false\");\n          }\n        },\n      );\n\n      button.label = label;\n      button.addEventListener(\"click\", increase);\n    });\n\n    clapped.on(\n      debounce(() => {\n        api.claps.add(clapped.get(), pathname);\n      }, 1000),\n    );\n\n    claps.on(setAmount);\n  },\n);\n", "import {\n  h,\n  splitPathStringToParts,\n} from \"../clientScript/clientDependencies.ts\";\n\nconst { add, span, wbr } = h;\n\nconst classPrefix = \"fileInText\";\n\nexport const splitHTMLElementTextContent = (holderElement: HTMLElement) => {\n  const pathStr = holderElement.textContent;\n  if (pathStr == null || pathStr === \"\") {\n    holderElement.remove();\n    return;\n  }\n  const fileOnly = holderElement.dataset[\"fileOnly\"] === \"true\";\n\n  const pathParts = splitPathStringToParts(pathStr);\n  let recipient = holderElement;\n  if (fileOnly) {\n    const label = span(\n      { class: `${classPrefix}Label` },\n      pathParts.filename,\n    );\n    holderElement.textContent = \"\";\n    recipient = span({ class: `${classPrefix}Tooltip` });\n    add(holderElement, label, recipient);\n  }\n  recipient.textContent = \"\";\n  holderElement.classList.add(`${classPrefix}-${pathParts.fileType}`);\n\n  add(\n    recipient,\n    span({ class: `${classPrefix}Protocol` }, pathParts.protocol),\n    span({ class: `${classPrefix}Slash` }, \"://\"),\n    pathParts.dirname.length > 0\n      ? pathParts.dirname.map((chunk) => [\n        span({ class: `${classPrefix}Directory` }, chunk),\n        span({ class: `${classPrefix}Slash` }, \"/\"),\n        wbr(),\n      ])\n      : undefined,\n    pathParts.filename &&\n      span({ class: `${classPrefix}File` }, pathParts.filename),\n  );\n};\n\ndocument.querySelectorAll<HTMLSpanElement>('[data-is=\"file-in-text\"]').forEach(\n  splitHTMLElementTextContent,\n);\n", "import { splitHTMLElementTextContent } from \"./fileInText.client.ts\";\n\ndocument.querySelectorAll<HTMLSpanElement>(\".codeBlockFileName\").forEach(\n  splitHTMLElementTextContent,\n);\n", "import {\n  h,\n  processDomElementOnce,\n} from \"../clientScript/clientDependencies.ts\";\nconst { add, button } = h;\n\ntype RevealButtonElement = HTMLButtonElement & {\n  content: HTMLElement;\n  caption: HTMLElement;\n};\n\nfunction onRevealButtonClick(this: RevealButtonElement) {\n  const shouldOpen = this.getAttribute(\"aria-expanded\") !== \"true\";\n  if (shouldOpen) {\n    this.setAttribute(\"aria-expanded\", \"true\");\n    this.content.removeAttribute(\"aria-hidden\");\n    this.caption.removeAttribute(\"data-closed\");\n  } else {\n    this.setAttribute(\"aria-expanded\", \"false\");\n    this.content.setAttribute(\"aria-hidden\", \"true\");\n    this.caption.setAttribute(\"data-closed\", \"\");\n  }\n}\n\nexport const makeRevealButton = (\n  summary?: HTMLElement | null,\n  details?: HTMLElement | null,\n) => {\n  if (!details || !summary) {\n    return;\n  }\n  const id = details.id || `collapsible-${Math.random().toString(36).slice(2)}`;\n  if (!details.id) {\n    details.id = id;\n  }\n  const isOpen = summary.hasAttribute(\"data-open\") &&\n    summary.getAttribute(\"data-open\") === \"true\";\n\n  const revealBtn = Object.assign(\n    button(\n      {\n        class: \"collapsibleRevealButton\",\n        ariaExpanded: isOpen ? \"true\" : \"false\",\n        ariaControls: id,\n        ariaLabel: \"Toggle content\",\n        // @ts-expect-error impossible to type this\n        onclick: onRevealButtonClick,\n        type: \"button\",\n      },\n      ...Array.from(summary.childNodes),\n    ),\n    { content: details, caption: summary },\n  ) as RevealButtonElement;\n\n  if (!isOpen) {\n    details.setAttribute(\"aria-hidden\", \"true\");\n    summary.setAttribute(\"data-closed\", \"\");\n  }\n\n  return revealBtn;\n};\n\nprocessDomElementOnce(\"[data-is-disclosure\", (el) => {\n  const summary = el.querySelector<HTMLElement>(\".disclosureSummary\");\n  const details = el.querySelector<HTMLElement>(\".disclosureDetails\");\n  if (!summary || !details) {\n    return;\n  }\n  const button = makeRevealButton(summary, details);\n  if (!button) {\n    return;\n  }\n  add(summary, button);\n});\n", "import {\n  h,\n  processDomElementOnce,\n} from \"../clientScript/clientDependencies.ts\";\nimport { makeRevealButton } from \"./collapsibleElement.client.ts\";\nconst { add } = h;\n\nconst processCallout = (collapsiblesList: HTMLDListElement) => {\n  const captions = collapsiblesList.querySelectorAll<HTMLElement>(\"dt\");\n\n  captions.forEach((caption) => {\n    const content = caption.nextElementSibling as HTMLElement | null;\n\n    const revealButton = makeRevealButton(caption, content);\n\n    if (!revealButton) {\n      return;\n    }\n\n    caption.textContent = \"\";\n\n    add(caption, revealButton);\n  });\n};\n\nprocessDomElementOnce('[data-is=\"collapsible-list\"]', processCallout);\n", "/**\n * This module groups the logic to index and search the content of the library.\n *\n * Items are loaded and normalized at build time, then each query is evaluated\n * with rules that prioritize whole-phrase matches before falling back to\n * word-by-word scores and fuzzy matching (to still find relevant results even\n * with typos).\n */\nimport type { SearchableItem } from \"../../toolbox/content/item/03_resolved.ts\";\n\n/**\n * This structure gives the base weight of different queries that play a role in\n * which entries are surfaced in the search results.\n */\nconst SCORE = {\n  // These match the full user query phrase: When the complete search query\n  // (e.g., \"game engine\") appears in a library entry's fields, we apply these high-value\n  // scores to surface the most relevant results first.\n  //\n  // For example, a query of \"game engine\" would match:\n  //\n  // - Exact match: A tag or search keyword like \"game engine\"\n  // - Prefix match: A title like \"Game engine basics\"\n  // - Substring match: A title like \"What is a game engine and what does it do\"\n  QUERY_EXACT: 450,\n  QUERY_PREFIX: 325,\n  QUERY_SUBSTRING: 200,\n\n  // Token-based matching: After evaluating the entire search query, we split\n  // the query into individual tokens (words) and score each against the title,\n  // keywords, tags, and categories.\n  TITLE_PREFIX: 100,\n  TITLE_WORD: 50,\n  TITLE_SUBSTRING: 12,\n  KEYWORD_EXACT: 50,\n  KEYWORD_PARTIAL: 20,\n  TAG_EXACT: 25,\n  TAG_PARTIAL: 10,\n  CATEGORY_MATCH: 10,\n\n  // Fuzzy matching: When exact and partial matches fail, we calculate a distance\n  // to find results even when the user makes typos.\n  FUZZY_BASE_SCORE: 12,\n} as const;\n\n// This is the minimum score an entry needs to reach to appear in the search\n// results. Lower this to get more results, raise it to get fewer but more\n// relevant results.\nconst MIN_SCORE = 4;\n// This score is a threshold for how similar two strings must be to be considered\n// a match. It allows users to still find relevant results even when they make\n// typos in their query. This is a number between 0.0 and 1.0.\n// Lower values catch more typos but may produce false positives.\nconst MIN_TRIGRAM_SIMILARITY = 0.25;\nconst SUGGESTION_LENGTH_MIN = 2;\nconst SUGGESTION_LENGTH_MAX = 48;\nconst SUGGESTION_WORDS_MAX = 6;\n\n/**\n * Normalizes text for consistent searching and matching.\n *\n * We do:\n * 1. NFD normalization: it separates characters with diacritics into their base\n * characters (e.g.,  becomes e + the accent mark). This extracts the\n * diacritics.\n * 2. Erase the extracted diacritics, which leaves us with just the base\n * characters.\n * 3. Converts to lowercase so search is case-insensitive.\n *\n * Even though we only have English now, I've added it because:\n * 1. If people write melee it'll match mle, which we have in a title\n * 2. If people use borrowed words or mistype something on an international\n * keyboard, it improves the chances of matching.\n */\nconst normalizeText = (value: string): string =>\n  value\n    .normalize(\"NFD\")\n    .replace(/[\\u0300-\\u036f]/g, \"\")\n    .toLowerCase();\n\nconst tokenize = (value: string): string[] =>\n  normalizeText(value)\n    .split(/[^a-z0-9]+/)\n    .filter(Boolean);\n\nconst removeDuplicates = (values: string[]): string[] =>\n  Array.from(new Set(values));\n\nconst normalizeList = (values: string[]): string[] =>\n  removeDuplicates(values.map(normalizeText));\n\nconst expandWithTokens = (values: string[]): string[] =>\n  removeDuplicates(values.flatMap((value) => [value, ...tokenize(value)]));\n\nconst humanizeText = (value: string): string =>\n  value\n    .replace(/[_-]+/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n\nconst toSentenceCase = (value: string): string => {\n  const humanized = humanizeText(value);\n  if (!humanized) {\n    return \"\";\n  }\n  const lower = humanized.toLowerCase();\n  return lower.charAt(0).toUpperCase() + lower.slice(1);\n};\n\n/** The public shape returned by `search()`. */\nexport type SearchResult = {\n  item: SearchableItem;\n  score: number;\n};\n\n/**\n * Map of category -> allowed values, used when filtering results.\n */\nexport type SearchFilters = Record<string, Set<string>>;\n\n/**\n * Options to pass to the search() and filter() functions.\n * Mainly used to limit the number of results and set a minimum score.\n */\nexport interface SearchOptions {\n  limit?: number;\n  minScore?: number;\n  filters?: SearchFilters;\n}\n\nconst FILTER_ONLY_SCORE = 1;\n\n/**\n * Main entry point for the search system. It's returned by the factory function\n * createLibrarySearchEngine().\n */\nexport interface LibrarySearchEngine {\n  search: (query: string, options?: SearchOptions) => SearchResult[];\n  filter: (options?: SearchOptions) => SearchResult[];\n  suggest: (query: string, limit?: number) => string[];\n  total: number;\n}\n\ntype FilterableFields = {\n  entry_type: string;\n  format: string[];\n  tool_version: string[];\n  game_space: string[];\n  game_genre: string[];\n  subject_tags: string[];\n};\n\n/** This stores a token along with its pre-computed trigrams. */\ntype TokenWithTrigrams = {\n  value: string;\n  trigrams: Set<string>;\n};\n\n/**\n * Cached, normalized representation of a SearchableItem.\n * We normalize and tokenize everything once so we never repeat string work\n * inside tight scoring loops.\n */\ntype NormalizedSearchEntry = {\n  item: SearchableItem;\n  title: string;\n  titleTokens: string[];\n  keywords: string[];\n  keywordTokens: string[];\n  tags: string[];\n  tagTokens: string[];\n  categories: string[];\n  filterableFields: FilterableFields;\n  isArchived: boolean;\n  // All phrase values flattened for full-query matching\n  allPhraseValues: string[];\n  // All tokens with trigrams flattened for fuzzy matching\n  allTokensWithTrigrams: TokenWithTrigrams[];\n};\n\n/**\n * Generates trigrams from a string. A trigram is a sequence of 3 consecutive characters.\n * For example, \"save\" produces: [\"  s\", \" sa\", \"sav\", \"ave\", \"ve \"]\n * Padding with spaces helps match at word boundaries.\n */\nconst generateTrigrams = (text: string): Set<string> => {\n  const trigrams = new Set<string>();\n  const padded = `  ${text} `;\n  for (let i = 0; i < padded.length - 2; i += 1) {\n    trigrams.add(padded.slice(i, i + 3));\n  }\n  return trigrams;\n};\n\n/**\n * Prepares a raw item for scoring. Everything is normalized and tokenized once so we\n * never repeat string munging work inside tight scoring loops.\n */\nconst normalizeEntry = (item: SearchableItem): NormalizedSearchEntry => {\n  const title = normalizeText(item.title);\n  const titleTokens = tokenize(item.title);\n\n  const keywords = normalizeList(item.search);\n  const keywordTokens = expandWithTokens(keywords);\n\n  const tags = normalizeList(item.subject_tags);\n  const tagTokens = expandWithTokens(tags);\n\n  const categories = normalizeList([\n    item.entry_type,\n    ...item.format,\n    ...item.tool_version,\n    ...item.game_space,\n    ...item.game_genre,\n  ]);\n\n  const filterableFields = {\n    entry_type: item.entry_type,\n    format: item.format,\n    tool_version: item.tool_version,\n    game_space: item.game_space,\n    game_genre: item.game_genre,\n    subject_tags: item.subject_tags,\n  };\n\n  const isArchived =\n    (item as SearchableItem & { archived?: boolean }).archived ?? false;\n\n  // We flatten all \"phrases\" to make it easier to match the full query against them\n  // Then, we flatten all tokens with pre-computed trigrams for fuzzy matching\n  const allPhraseValues = [title, ...keywords, ...tags, ...categories];\n  const allTokens = removeDuplicates([\n    ...titleTokens,\n    ...keywordTokens,\n    ...tagTokens,\n    ...categories,\n  ]);\n  const allTokensWithTrigrams = allTokens.map((value) => ({\n    value,\n    trigrams: generateTrigrams(value),\n  }));\n\n  return {\n    item,\n    title,\n    titleTokens,\n    keywords,\n    keywordTokens,\n    tags,\n    tagTokens,\n    categories,\n    filterableFields,\n    isArchived,\n    allPhraseValues,\n    allTokensWithTrigrams,\n  };\n};\n\n/**\n * Builds suggestion entries during the initial normalization pass.\n * Returns array of [normalizedValue, displayValue] pairs sorted alphabetically.\n */\nconst buildSuggestionEntries = (\n  normalizedEntries: NormalizedSearchEntry[],\n): [string, string][] => {\n  const pool = new Map<string, string>();\n\n  const addCandidate = (value: string) => {\n    if (!value) {\n      return;\n    }\n    const displayValue = toSentenceCase(value);\n    if (!displayValue) {\n      return;\n    }\n    const wordCount = displayValue.split(/\\s+/).length;\n    if (\n      displayValue.length > SUGGESTION_LENGTH_MAX ||\n      wordCount > SUGGESTION_WORDS_MAX\n    ) {\n      return;\n    }\n    const normalizedValue = normalizeText(displayValue);\n    if (normalizedValue.length < SUGGESTION_LENGTH_MIN) {\n      return;\n    }\n    if (pool.has(normalizedValue)) {\n      return;\n    }\n    pool.set(normalizedValue, displayValue);\n  };\n\n  for (const entry of normalizedEntries) {\n    const item = entry.item;\n    item.search.forEach(addCandidate);\n    item.subject_tags.forEach(addCandidate);\n    addCandidate(item.entry_type);\n    item.format.forEach(addCandidate);\n    item.tool_version.forEach(addCandidate);\n    item.game_space.forEach(addCandidate);\n    item.game_genre.forEach(addCandidate);\n  }\n\n  return Array.from(pool.entries()).sort(([, a], [, b]) => a.localeCompare(b));\n};\n\nconst CATEGORY_TO_FIELD: Record<string, keyof FilterableFields> = {\n  entry_type: \"entry_type\",\n  format: \"format\",\n  tool_version: \"tool_version\",\n  game_space: \"game_space\",\n  game_genre: \"game_genre\",\n  subject_tag: \"subject_tags\",\n  subject_tags: \"subject_tags\",\n};\n\nconst matchesFilters = (\n  entry: NormalizedSearchEntry,\n  filters: SearchFilters,\n): boolean => {\n  for (const [category, allowedValues] of Object.entries(filters)) {\n    if (allowedValues.size === 0) {\n      continue;\n    }\n    const fieldKey = CATEGORY_TO_FIELD[category];\n    if (!fieldKey) {\n      continue;\n    }\n    const fieldValue = entry.filterableFields[fieldKey];\n    let hasMatch = false;\n    if (Array.isArray(fieldValue)) {\n      hasMatch = fieldValue.some((value) => allowedValues.has(value));\n    } else if (typeof fieldValue === \"string\") {\n      hasMatch = allowedValues.has(fieldValue);\n    }\n    if (!hasMatch) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst hasActiveFilters = (filters?: SearchFilters): boolean =>\n  !!filters && Object.values(filters).some((set) => set.size > 0);\n\n/**\n * Sorts search results, prioritizing Godot 4 items first, then by score, then\n * alphabetically by title.\n */\nconst sortSearchResults = (a: SearchResult, b: SearchResult): number => {\n  const aIsGodot4 = a.item.tool_version.includes(\"godot_4\");\n  const bIsGodot4 = b.item.tool_version.includes(\"godot_4\");\n\n  if (aIsGodot4 && !bIsGodot4) {\n    return -1;\n  }\n  if (!aIsGodot4 && bIsGodot4) {\n    return 1;\n  }\n\n  if (b.score === a.score) {\n    return a.item.title.localeCompare(b.item.title);\n  }\n  return b.score - a.score;\n};\n\nconst sortByTitle = (a: SearchResult, b: SearchResult): number =>\n  a.item.title.localeCompare(b.item.title);\n\n/**\n * Calculates trigram similarity between two pre-computed trigram sets.\n * Returns a value between 0.0 (no similarity) and 1.0 (identical).\n */\nconst trigramSimilarity = (\n  trigramsA: Set<string>,\n  trigramsB: Set<string>,\n  minSimilarity = MIN_TRIGRAM_SIMILARITY,\n): number | null => {\n  let intersectionSize = 0;\n  for (const trigram of trigramsA) {\n    if (trigramsB.has(trigram)) {\n      intersectionSize += 1;\n    }\n  }\n  const unionSize = trigramsA.size + trigramsB.size - intersectionSize;\n  if (unionSize === 0) {\n    return null;\n  }\n  const similarity = intersectionSize / unionSize;\n  return similarity >= minSimilarity ? similarity : null;\n};\n\n/**\n * Gives a sizeable score boost when the complete normalized query appears in one of the\n * entry fields. This runs before token-level evaluation so perfect and near-perfect\n * phrase hits always outrank loosely related content.\n */\nconst evaluateFullQuery = (\n  entry: NormalizedSearchEntry,\n  normalizedQuery: string,\n): number => {\n  if (!normalizedQuery) {\n    return 0;\n  }\n\n  let bestScore = 0;\n\n  for (const candidate of entry.allPhraseValues) {\n    if (!candidate) {\n      continue;\n    }\n    if (candidate === normalizedQuery) {\n      return SCORE.QUERY_EXACT;\n    }\n    if (candidate.startsWith(normalizedQuery)) {\n      if (SCORE.QUERY_PREFIX > bestScore) {\n        bestScore = SCORE.QUERY_PREFIX;\n      }\n    } else if (candidate.includes(normalizedQuery)) {\n      if (SCORE.QUERY_SUBSTRING > bestScore) {\n        bestScore = SCORE.QUERY_SUBSTRING;\n      }\n    }\n  }\n\n  return bestScore;\n};\n\n/**\n * Scores a single token against the various fields (title, keywords, tags, categories),\n * falling back to typo tolerance when nothing else matches.\n */\nconst evaluateToken = (\n  entry: NormalizedSearchEntry,\n  token: string,\n  queryTrigrams: Set<string>,\n): number => {\n  let bestScore = 0;\n\n  // Match against the title first\n  if (entry.title.startsWith(token)) {\n    bestScore = SCORE.TITLE_PREFIX;\n  } else if (entry.titleTokens.some((word) => word.startsWith(token))) {\n    bestScore = SCORE.TITLE_WORD;\n  } else if (entry.title.includes(token)) {\n    bestScore = SCORE.TITLE_SUBSTRING;\n  }\n\n  // Then check the tags\n  if (entry.tags.includes(token)) {\n    if (SCORE.TAG_EXACT > bestScore) {\n      bestScore = SCORE.TAG_EXACT;\n    }\n  } else if (entry.tagTokens.some((tag) => tag.startsWith(token))) {\n    if (SCORE.TAG_PARTIAL > bestScore) {\n      bestScore = SCORE.TAG_PARTIAL;\n    }\n  } else if (entry.tagTokens.some((tag) => tag.includes(token))) {\n    const score = SCORE.TAG_PARTIAL - 20;\n    if (score > bestScore) {\n      bestScore = score;\n    }\n  }\n\n  // Check keywords\n  if (entry.keywords.includes(token)) {\n    if (SCORE.KEYWORD_EXACT > bestScore) {\n      bestScore = SCORE.KEYWORD_EXACT;\n    }\n  } else if (entry.keywordTokens.some((kw) => kw.startsWith(token))) {\n    if (SCORE.KEYWORD_PARTIAL > bestScore) {\n      bestScore = SCORE.KEYWORD_PARTIAL;\n    }\n  } else if (entry.keywordTokens.some((kw) => kw.includes(token))) {\n    const score = SCORE.KEYWORD_PARTIAL - 20;\n    if (score > bestScore) {\n      bestScore = score;\n    }\n  }\n\n  if (entry.categories.includes(token)) {\n    if (SCORE.CATEGORY_MATCH > bestScore) {\n      bestScore = SCORE.CATEGORY_MATCH;\n    }\n  } else if (entry.categories.some((cat) => cat.includes(token))) {\n    if (SCORE.CATEGORY_MATCH > bestScore) {\n      bestScore = SCORE.CATEGORY_MATCH;\n    }\n  }\n\n  // We only use fuzzy matching if nothing else that has more weight matched (no\n  // need to check for typos if we have a strong match for this token already)\n  if (bestScore === 0) {\n    // Short tokens get a stricter similarity threshold so typos don't match too\n    // easily (this is to avoid false positives)\n    const minSimilarity = token.length >= 5 ? MIN_TRIGRAM_SIMILARITY : 0.5;\n\n    for (const candidate of entry.allTokensWithTrigrams) {\n      const similarity = trigramSimilarity(\n        candidate.trigrams,\n        queryTrigrams,\n        minSimilarity,\n      );\n      if (similarity == null) {\n        continue;\n      }\n      const normalizedSimilarity = (similarity - minSimilarity) /\n        (1.0 - minSimilarity);\n      const typoScore = Math.floor(\n        SCORE.FUZZY_BASE_SCORE * (0.5 + normalizedSimilarity * 0.5),\n      );\n      if (typoScore > bestScore) {\n        bestScore = typoScore;\n      }\n    }\n  }\n\n  return bestScore;\n};\n\n/**\n * Calculates the final score for an entry, combining phrase-level bonuses and per-token hits.\n */\nconst scoreEntry = (\n  entry: NormalizedSearchEntry,\n  tokens: string[],\n  tokenTrigrams: Set<string>[],\n  normalizedQuery: string,\n): number | null => {\n  let total = evaluateFullQuery(entry, normalizedQuery);\n\n  for (let i = 0; i < tokens.length; i++) {\n    const tokenScore = evaluateToken(entry, tokens[i], tokenTrigrams[i]);\n    if (tokenScore === 0) {\n      return null;\n    }\n    total += tokenScore;\n  }\n\n  return total === 0 ? null : total;\n};\n\n/**\n * Public factory that accepts the raw `SearchableItem` array and returns handy helpers\n * for searching, filtering, and generating query suggestions.\n */\nexport const createLibrarySearchEngine = (\n  items: SearchableItem[],\n): LibrarySearchEngine => {\n  const normalized = items.map(normalizeEntry);\n  const suggestionEntries = buildSuggestionEntries(normalized);\n\n  const filter = (options: SearchOptions = {}): SearchResult[] => {\n    const filters = options.filters;\n    if (!hasActiveFilters(filters) || !filters) {\n      return [];\n    }\n    const results: SearchResult[] = [];\n    for (const entry of normalized) {\n      if (matchesFilters(entry, filters)) {\n        results.push({ item: entry.item, score: FILTER_ONLY_SCORE });\n      }\n    }\n    results.sort(sortByTitle);\n    if (typeof options.limit === \"number\" && options.limit > 0) {\n      return results.slice(0, options.limit);\n    }\n    return results;\n  };\n\n  const search = (\n    query: string,\n    options: SearchOptions = {},\n  ): SearchResult[] => {\n    const sanitized = query.trim();\n    const filters = options.filters;\n    const filtersEnabled = hasActiveFilters(filters);\n\n    if (!sanitized) {\n      return filtersEnabled ? filter(options) : [];\n    }\n    const normalizedQuery = normalizeText(sanitized);\n    if (!normalizedQuery) {\n      return filtersEnabled ? filter(options) : [];\n    }\n    const tokens = tokenize(sanitized);\n    if (tokens.length === 0) {\n      return filtersEnabled ? filter(options) : [];\n    }\n\n    // Pre-compute trigrams for all query tokens once\n    const tokenTrigrams = tokens.map(generateTrigrams);\n\n    const minScore = options.minScore ?? MIN_SCORE;\n    const activeResults: SearchResult[] = [];\n    const archivedResults: SearchResult[] = [];\n\n    for (const entry of normalized) {\n      if (filtersEnabled && filters && !matchesFilters(entry, filters)) {\n        continue;\n      }\n      const score = scoreEntry(entry, tokens, tokenTrigrams, normalizedQuery);\n      if (score != null && score >= minScore) {\n        const result = { item: entry.item, score };\n        if (entry.isArchived) {\n          archivedResults.push(result);\n        } else {\n          activeResults.push(result);\n        }\n      }\n    }\n\n    // Sort active and archived results separately, then combine\n    activeResults.sort(sortSearchResults);\n    archivedResults.sort(sortSearchResults);\n    const results = [...activeResults, ...archivedResults];\n\n    if (typeof options.limit === \"number\" && options.limit > 0) {\n      return results.slice(0, options.limit);\n    }\n    return results;\n  };\n\n  const suggest = (query: string, limit = 6): string[] => {\n    if (limit <= 0) {\n      return [];\n    }\n    const sanitized = query.trim();\n    if (!sanitized) {\n      return [];\n    }\n    const normalizedQuery = normalizeText(sanitized);\n    if (!normalizedQuery) {\n      return [];\n    }\n\n    const prefixMatches: string[] = [];\n    const substringMatches: string[] = [];\n\n    for (const [normalizedValue, displayValue] of suggestionEntries) {\n      if (normalizedValue.startsWith(normalizedQuery)) {\n        prefixMatches.push(displayValue);\n      } else if (normalizedValue.includes(normalizedQuery)) {\n        substringMatches.push(displayValue);\n      }\n      if (prefixMatches.length >= limit) {\n        break;\n      }\n    }\n\n    if (prefixMatches.length < limit) {\n      for (const suggestion of substringMatches) {\n        prefixMatches.push(suggestion);\n        if (prefixMatches.length >= limit) {\n          break;\n        }\n      }\n    }\n\n    return prefixMatches.slice(0, limit);\n  };\n\n  return { search, filter, suggest, total: normalized.length };\n};\n\nexport type GlossarySearchItem = { slug: string; terms: string[] };\n\nexport type GlossarySearchResult = {\n  slug: string;\n  terms: string[];\n  score: number;\n};\n\nexport interface GlossarySearchEngine {\n  search: (query: string, options?: SearchOptions) => GlossarySearchResult[];\n  total: number;\n}\n\nconst normalizeGlossaryItem = (item: GlossarySearchItem) => ({\n  slug: item.slug,\n  terms: item.terms.map((term) => ({\n    raw: term,\n    normalized: normalizeText(term),\n    tokens: tokenize(term),\n  })),\n});\n\nexport const createGlossarySearchEngine = (\n  items: GlossarySearchItem[],\n): GlossarySearchEngine => {\n  const normalized = items.map(normalizeGlossaryItem);\n\n  const search = (\n    query: string,\n    options: SearchOptions = {},\n  ): GlossarySearchResult[] => {\n    const sanitized = query.trim();\n    if (!sanitized) {\n      return [];\n    }\n    const token = normalizeText(sanitized);\n    const tokenTrigrams = generateTrigrams(token);\n    const minScore = options.minScore ?? MIN_SCORE;\n    const results: GlossarySearchResult[] = [];\n\n    for (const entry of normalized) {\n      let bestScore = 0;\n      for (const term of entry.terms) {\n        if (term.normalized.startsWith(token)) {\n          bestScore = SCORE.TAG_EXACT;\n          break;\n        }\n        if (term.tokens.some((value) => value.startsWith(token))) {\n          bestScore = Math.max(bestScore, SCORE.TAG_PARTIAL);\n        } else if (term.normalized.includes(token)) {\n          bestScore = Math.max(bestScore, SCORE.KEYWORD_PARTIAL);\n        } else {\n          const termTrigrams = generateTrigrams(term.normalized);\n          const similarity = trigramSimilarity(termTrigrams, tokenTrigrams);\n          if (similarity != null) {\n            const typoScore = Math.floor(SCORE.FUZZY_BASE_SCORE * similarity);\n            bestScore = Math.max(bestScore, typoScore);\n          }\n        }\n      }\n      if (bestScore >= minScore) {\n        results.push({\n          slug: entry.slug,\n          terms: entry.terms.map((t) => t.raw),\n          score: bestScore,\n        });\n      }\n    }\n\n    results.sort((a, b) => {\n      if (b.score === a.score) {\n        return a.slug.localeCompare(b.slug);\n      }\n      return b.score - a.score;\n    });\n\n    if (typeof options.limit === \"number\" && options.limit > 0) {\n      return results.slice(0, options.limit);\n    }\n    return results;\n  };\n\n  return { search, total: normalized.length };\n};\n", "import {\n  debounce,\n  FetcherSignal,\n  type GlossaryDictionaryKeys,\n  processDomElementOnce,\n} from \"../clientScript/clientDependencies.ts\";\nimport {\n  createGlossarySearchEngine,\n  type GlossarySearchItem,\n} from \"../clientScript/searchEngine.ts\";\n\nconst classPrefixSearch = \"glossarySearch\";\nconst classPrefixList = \"glossaryList\";\n\nfunction setElementDisabled(this: HTMLElement, doDisable: boolean) {\n  if (doDisable) {\n    this.classList.add(\"disabled\");\n    this.setAttribute(\"aria-disabled\", \"true\");\n    this.setAttribute(\"hidden\", \"true\");\n    this.setAttribute(\"tabindex\", \"-1\");\n    this.dataset.href = this.getAttribute(\"href\") ?? \"\";\n    this.removeAttribute(\"href\");\n  } else {\n    this.classList.remove(\"disabled\");\n    this.removeAttribute(\"aria-disabled\");\n    this.removeAttribute(\"hidden\");\n    this.removeAttribute(\"tabindex\");\n    if (this.dataset.href) {\n      this.setAttribute(\"href\", this.dataset.href);\n      delete this.dataset.href;\n    }\n  }\n}\n\nprocessDomElementOnce(`.${classPrefixSearch}`, (element) => {\n  const form = element.querySelector(\"form\");\n  if (!form) {\n    console.error(\"No form found in glossary search component\");\n    return;\n  }\n\n  form.addEventListener(\"submit\", (event) => {\n    event.preventDefault();\n  });\n\n  const input = form.querySelector(\"input[type='search']\") as HTMLInputElement;\n  if (!input) {\n    console.error(\"No input found in glossary search component\");\n    return;\n  }\n\n  const noSearchResultsElement = document.querySelector(\n    `#${classPrefixList}NothingFound`,\n  ) as HTMLLIElement;\n  if (!noSearchResultsElement) {\n    console.error(\n      \"No element with ID glossaryListNothingFound found in glossary search component\",\n    );\n    return;\n  }\n\n  const dataURL = element.dataset.searchUrl;\n  if (!dataURL) {\n    console.error(\n      \"No data-fuse-url attribute found in glossary search component\",\n    );\n    return;\n  }\n\n  const searchTerms = new Map(\n    Array.from(\n      document.querySelectorAll<HTMLLIElement>(\n        `.${classPrefixList} li.${classPrefixList}TermItem[data-slug]`,\n      ),\n    ).map((el) => {\n      const slug = el.dataset.slug!;\n      return [slug, el] as const;\n    }),\n  );\n\n  const tocAnchors = new Map(\n    Array.from(document.querySelectorAll<HTMLAnchorElement>(\n      \"#tableOfContentsPane a.tableOfContentsAnchorLinkToH2[href^='#glossary-letter-']\",\n    )).map((a) => {\n      const letter = a.getAttribute(\"href\")!.replace(\"#glossary-letter-\", \"\");\n      const augmentedAnchor = a as HTMLAnchorElement & {\n        setAnchorDisabled: (doDisable: boolean) => void;\n      };\n      augmentedAnchor.setAnchorDisabled = setElementDisabled;\n      return [letter, augmentedAnchor] as const;\n    }),\n  );\n\n  const searchInputAnchors = new Map(\n    Array.from(\n      element.querySelectorAll<HTMLAnchorElement>(\n        \".glossarySearchJumpLinks a\",\n      ),\n    ).map((a) => {\n      const letter = a.getAttribute(\"href\")!.replace(\"#glossary-letter-\", \"\");\n      const augmentedAnchor = a as HTMLAnchorElement & {\n        setAnchorDisabled: (doDisable: boolean) => void;\n      };\n      augmentedAnchor.setAnchorDisabled = setElementDisabled;\n      return [letter, augmentedAnchor] as const;\n    }),\n  );\n\n  const sections = new Map(\n    Array.from(\n      document.querySelectorAll<HTMLLIElement>(\n        \"#glossaryList li[id^='glossarySection-letter-'][data-letter]\",\n      ),\n    ).map((section) => {\n      const letter = section.dataset.letter! as GlossaryDictionaryKeys;\n      const element = section as HTMLLIElement & {\n        setSectionDisabled: (doDisable: boolean) => void;\n      };\n      element.setSectionDisabled = setElementDisabled;\n      return [letter, element] as const;\n    }),\n  );\n\n  type Data = {\n    items: GlossarySearchItem[];\n    metadata: {\n      version: number;\n      generatedAt: string;\n    };\n  };\n\n  const onSearchLoaded = (data: Data) => {\n    const engine = createGlossarySearchEngine(data.items);\n    const onInputEnter = debounce(() => {\n      const query = input.value.trim();\n      if (query.length === 0) {\n        tocAnchors.forEach((a) => a.setAnchorDisabled(false));\n        searchInputAnchors.forEach((a) => a.setAnchorDisabled(false));\n        sections.forEach((s) => s.setSectionDisabled(false));\n        noSearchResultsElement.hidden = true;\n        searchTerms.forEach((term) => term.removeAttribute(\"hidden\"));\n        return;\n      }\n      const results = engine.search(query);\n      tocAnchors.forEach((a) => a.setAnchorDisabled(true));\n      searchInputAnchors.forEach((a) => a.setAnchorDisabled(true));\n      sections.forEach((s) => s.setSectionDisabled(true));\n      noSearchResultsElement.hidden = results.length > 0;\n      searchTerms.forEach((term) => term.setAttribute(\"hidden\", \"true\"));\n      if (results.length > 0) {\n        results.forEach(({ slug, terms }) => {\n          searchTerms.get(slug)?.removeAttribute(\"hidden\");\n          const firstTerm = terms[0] ?? \"\";\n          const letter = firstTerm.charAt(0).toLocaleUpperCase();\n          const key = (letter.match(/[0-9]/) ? \"1-9\" : letter) as\n            GlossaryDictionaryKeys;\n          tocAnchors.get(key)?.setAnchorDisabled(false);\n          searchInputAnchors.get(key)?.setAnchorDisabled(false);\n          sections.get(key)?.setSectionDisabled(false);\n        });\n      }\n    }, 150);\n\n    input.addEventListener(\"input\", onInputEnter);\n    if (input.value.trim().length > 0) {\n      onInputEnter();\n    }\n  };\n\n  const searchLoadedData = FetcherSignal<Data>();\n\n  searchLoadedData.on(({ status, data }) => {\n    if (status === \"success\") {\n      onSearchLoaded(data);\n    }\n  });\n\n  searchLoadedData.load(dataURL);\n});\n", "type SuggestionsDropdownConfig = {\n  classPrefix: string;\n  container: HTMLDivElement;\n  input: HTMLInputElement;\n  onSelect: (value: string) => void;\n};\n\ntype SuggestionsDropdownController = {\n  render: (items: string[]) => void;\n  clear: () => void;\n  handleKey: (event: KeyboardEvent) => boolean;\n};\n\nconst createId = (prefix: string) =>\n  `${prefix}-${Math.random().toString(36).slice(2)}`;\n\nexport const createSuggestionsDropdown = ({\n  classPrefix,\n  container,\n  input,\n  onSelect,\n}: SuggestionsDropdownConfig): SuggestionsDropdownController => {\n  let suggestions: string[] = [];\n  let highlightedIndex = -1;\n  let buttons: HTMLButtonElement[] = [];\n  const activeClass = `${classPrefix}SuggestionActive`;\n\n  container.hidden = true;\n  container.setAttribute(\"role\", \"presentation\");\n\n  const listId = createId(`${classPrefix}SuggestionsList`);\n  const list = document.createElement(\"ul\");\n  list.className = `${classPrefix}SuggestionsList`;\n  list.id = listId;\n  list.setAttribute(\"role\", \"listbox\");\n  list.setAttribute(\"aria-label\", \"Search suggestions\");\n  container.append(list);\n\n  input.setAttribute(\"aria-controls\", listId);\n  input.setAttribute(\"aria-expanded\", \"false\");\n  input.setAttribute(\"aria-autocomplete\", \"list\");\n  input.setAttribute(\"role\", \"combobox\");\n  input.setAttribute(\"aria-haspopup\", \"listbox\");\n\n  const optionIdPrefix = createId(`${classPrefix}SuggestionOption`);\n\n  const clear = () => {\n    suggestions = [];\n    highlightedIndex = -1;\n    buttons = [];\n    list.textContent = \"\";\n    container.hidden = true;\n    input.setAttribute(\"aria-expanded\", \"false\");\n    input.removeAttribute(\"aria-activedescendant\");\n  };\n\n  const select = (index: number) => {\n    const suggestion = suggestions[index];\n    if (!suggestion) return;\n    input.value = suggestion;\n    onSelect(suggestion);\n    clear();\n  };\n\n  const setHighlighted = (index: number) => {\n    highlightedIndex = index;\n    buttons.forEach((button, idx) => {\n      const isActive = idx === highlightedIndex;\n      button.classList.toggle(activeClass, isActive);\n      button.setAttribute(\"aria-selected\", String(isActive));\n    });\n    const activeButton = buttons[highlightedIndex];\n    if (activeButton) {\n      input.setAttribute(\"aria-activedescendant\", activeButton.id);\n    } else {\n      input.removeAttribute(\"aria-activedescendant\");\n    }\n  };\n\n  const render = (items: string[]) => {\n    if (items.length === 0) {\n      clear();\n      return;\n    }\n    suggestions = items;\n    highlightedIndex = -1;\n    buttons = [];\n    list.textContent = \"\";\n    container.hidden = false;\n    input.setAttribute(\"aria-expanded\", \"true\");\n\n    for (const [index, suggestion] of suggestions.entries()) {\n      const entry = document.createElement(\"li\");\n      entry.className = `${classPrefix}Suggestion`;\n      entry.setAttribute(\"role\", \"presentation\");\n\n      const button = document.createElement(\"button\");\n      button.type = \"button\";\n      button.className = `${classPrefix}SuggestionButton`;\n      button.id = `${optionIdPrefix}-${index}`;\n      button.setAttribute(\"role\", \"option\");\n      button.setAttribute(\"aria-selected\", \"false\");\n      button.textContent = suggestion;\n      button.addEventListener(\"mousedown\", (e) => e.preventDefault());\n      button.addEventListener(\"click\", () => select(index));\n\n      entry.append(button);\n      list.append(entry);\n      buttons.push(button);\n    }\n  };\n\n  const handleKey = (event: KeyboardEvent) => {\n    if (buttons.length === 0) return false;\n\n    if (event.key === \"ArrowDown\") {\n      setHighlighted((highlightedIndex + 1) % buttons.length);\n      return true;\n    }\n    if (event.key === \"ArrowUp\") {\n      setHighlighted((highlightedIndex - 1 + buttons.length) % buttons.length);\n      return true;\n    }\n    if (event.key === \"Enter\" && highlightedIndex >= 0) {\n      select(highlightedIndex);\n      return true;\n    }\n    if (event.key === \"Escape\") {\n      clear();\n      return true;\n    }\n    return false;\n  };\n\n  document.addEventListener(\"click\", (event) => {\n    const target = event.target as Node;\n    if (!container.contains(target) && target !== input) {\n      clear();\n    }\n  });\n\n  return { render, clear, handleKey };\n};\n", "import {\n  DataBearingError,\n  debounce,\n  ensureAllElementsNotNull,\n  FetcherSignal,\n  h,\n  pick,\n  processDomElementOnce,\n  querySelector,\n  querySelectorAll,\n  type SearchableItem,\n  searchParamsToObj,\n  Signal,\n} from \"../clientScript/clientDependencies.ts\";\nimport {\n  createLibrarySearchEngine,\n  type SearchFilters,\n  type SearchResult,\n} from \"../clientScript/searchEngine.ts\";\nimport { createSuggestionsDropdown } from \"../clientScript/mainSearchSuggestions.ts\";\n\nconst { span, replace, a, em } = h;\n\nconst classPrefix = \"mainSearch\";\n\nprocessDomElementOnce<HTMLDivElement>(\n  `.${classPrefix}`,\n  (searchWrapper) => {\n    /**\n     * Removes the loading overlay and enables pointer events on the search bar\n     * We have to declare this here so it can be used everywhere else below\n     */\n    const enableUI = () => {\n      const loadingOverlay = querySelector(`.${classPrefix}Loading`, {\n        parent: searchWrapper,\n      });\n      loadingOverlay?.addEventListener(\n        \"transitionend\",\n        () => {\n          loadingOverlay.remove();\n        },\n        { once: true },\n      );\n      searchWrapper.classList.add(\"loaded\");\n      searchWrapper.style.removeProperty(\"pointer-events\");\n    };\n\n    /*********************************************************\n     *\n     * INTEGRITY CHECK\n     *\n     * We verify we have everything we need\n     *\n     ********************************************************/\n\n    /**\n     * Determines if this is a page with filters. If it isn't one, we're not on the search page.\n     * In that case, we let the form behave normally and simply redirect to the search results page.\n     */\n    if (!(\"showFiltersButtons\" in searchWrapper.dataset)) {\n      enableUI();\n      return;\n    }\n\n    /** URL to load the search index from. If not found, it's an error and we exit early */\n    const dataURL = searchWrapper.dataset.searchUrl;\n    if (!dataURL) {\n      throw new DataBearingError(\n        enableUI,\n        \"No data URL provided for search index\",\n      );\n    }\n\n    /**\n     * All necessary elements for the search functionality.\n     * If one of them is missing, we bail\n     */\n    const elements = (() => {\n      const gridListId = searchWrapper.dataset.gridListId;\n      const summaryId = searchWrapper.dataset.summaryId;\n      // if there isn't anything to filter, we aren't on a search page. Exit early.\n      if (!gridListId || !summaryId) {\n        console.error(\n          \"No grid list or summary ID provided for search filtering\",\n        );\n        return;\n      }\n      return ensureAllElementsNotNull(\n        document.getElementById(gridListId),\n        document.getElementById(summaryId),\n        querySelector(`form`, { parent: searchWrapper }),\n        querySelector<HTMLInputElement>(`input[type=\"search\"]`, {\n          parent: searchWrapper,\n        }),\n        querySelector<HTMLDivElement>(`#${classPrefix}Filters`, {\n          parent: searchWrapper,\n        }),\n        querySelector<HTMLDivElement>(`.${classPrefix}SelectedTerms`, {\n          parent: searchWrapper,\n        }),\n        querySelector<HTMLDivElement>(`.${classPrefix}Suggestions`, {\n          parent: searchWrapper,\n        }),\n      );\n    })();\n\n    if (elements == null) {\n      throw new DataBearingError(\n        enableUI,\n        \"Some elements were not found in the DOM\",\n      );\n    }\n\n    const [\n      /** List of item cards */\n      gridList,\n      /** Summary element that displays \"X out of Y results\" */\n      summary,\n      /** Search form */\n      searchForm,\n      /** Search input inside the search form */\n      searchInput,\n      /** Filters container, options, checkboxes */\n      filtersContainer,\n      /** Selected terms container, buttons to remove selected filters */\n      selectedTermsContainer,\n      /** Suggestions dropdown container */\n      suggestionsContainer,\n    ] = elements;\n\n    searchForm.setAttribute(\"autocomplete\", \"off\");\n    searchInput.setAttribute(\"autocomplete\", \"off\");\n    searchInput.setAttribute(\"autocorrect\", \"off\");\n    searchInput.setAttribute(\"autocapitalize\", \"none\");\n    searchInput.setAttribute(\"spellcheck\", \"false\");\n\n    const cardsBeforeAugmentation = querySelectorAll<HTMLLIElement>(\n      \".itemCard\",\n      {\n        parent: gridList,\n      },\n    );\n    if (cardsBeforeAugmentation == null) {\n      throw new DataBearingError(\n        enableUI,\n        \"Cards were were not found in the DOM\",\n      );\n    }\n\n    /*********************************************************\n     *\n     * FILTERS UI BOOTSTRAP\n     *\n     * We prepare all the filtering elements here.\n     *\n     ********************************************************/\n\n    /**\n     * A map of all inputs used for filtering\n     * Each filter is augmented with a `linkedLabel` property that points to the corresponding selected term button\n     * Similarly, each selected term button has a `linkedInput` property that points to the corresponding input\n     */\n    const activeFiltersMap = (() => {\n      const filtersElements = ensureAllElementsNotNull(\n        querySelectorAll<HTMLInputElement | HTMLButtonElement>(\n          \"input, button.resetSection\",\n          {\n            parent: filtersContainer,\n          },\n        ),\n        querySelectorAll<ControlledLabel>(`label`, {\n          parent: selectedTermsContainer,\n        }),\n        querySelector<HTMLButtonElement>(\n          `.${classPrefix}SelectedTermsClearAllButton`,\n          {\n            parent: selectedTermsContainer,\n          },\n        ),\n      );\n\n      if (filtersElements == null) {\n        throw new DataBearingError(\n          enableUI,\n          \"Some filter elements were not found in the DOM\",\n        );\n      }\n\n      const [\n        /** Array of input elements inside the filters container. These are the checkboxes and options */\n        allFilterElements,\n        /** Array of label elements inside the selected terms container. These are the selected term buttons */\n        allSelectedTermLabels,\n        /** \"Clear all\" button that removes all selected filters */\n        clearAllButton,\n      ] = filtersElements;\n\n      type ControlledInput = HTMLInputElement & {\n        linkedLabel: HTMLLabelElement;\n      };\n\n      type ControlledLabel = HTMLLabelElement & {\n        linkedInput: HTMLInputElement;\n      };\n\n      const activeFiltersMap = Signal(new Map<string, Set<string>>());\n\n      const createFilterCategory = () => {\n        const selected = Signal(new Set<HTMLInputElement>());\n        const values = Signal(new Set<string>());\n\n        selected.on((newSelected) => {\n          const newValues = new Set<string>();\n          newSelected.forEach((input) => {\n            input.value.split(\" \").forEach((val) => newValues.add(val));\n          });\n          values.set(newValues);\n        });\n\n        return {\n          type: null as \"radio\" | \"checkbox\" | null,\n          mainInput: null as HTMLInputElement | null,\n          resetButton: null as HTMLButtonElement | null,\n          collection: new Set<ControlledInput>(),\n          selected,\n          values,\n        };\n      };\n\n      type FilterCategory = ReturnType<typeof createFilterCategory>;\n      type ProcessedFilterCategory =\n        & Omit<\n          FilterCategory,\n          \"type\" | \"mainInput\"\n        >\n        & {\n          type: \"radio\" | \"checkbox\";\n          mainInput: HTMLInputElement;\n        };\n\n      const filters = new Map<string, FilterCategory>();\n      const filtersById = new Map<string, ControlledInput>();\n\n      allFilterElements.forEach((inputOrButton) => {\n        const categoryName = inputOrButton.getAttribute(\"name\") || \"\";\n        // create the category if it doesn't exist,\n        // with associated values signal\n        if (!filters.has(categoryName)) {\n          activeFiltersMap.get().set(categoryName, new Set());\n          const category = createFilterCategory();\n          filters.set(categoryName, category);\n          category.values.on((newValues) => {\n            const currentValues = activeFiltersMap.get();\n            currentValues.set(categoryName, newValues);\n            activeFiltersMap.set(currentValues, true);\n          });\n        }\n        const category = filters.get(categoryName)!;\n        if (inputOrButton.tagName === \"BUTTON\") {\n          const button = inputOrButton as HTMLButtonElement;\n          category.resetButton = button;\n        } else {\n          const input = inputOrButton as HTMLInputElement;\n          if (input.classList.contains(\"resetSection\")) {\n            category.mainInput = input;\n          } else {\n            const controlledInput = input as ControlledInput;\n            category.collection.add(controlledInput);\n            if (category.type === null) {\n              category.type = input.type === \"radio\" ? \"radio\" : \"checkbox\";\n            }\n            filtersById.set(input.id, controlledInput);\n          }\n        }\n      });\n\n      allSelectedTermLabels.forEach((label) => {\n        const htmlFor = label.getAttribute(\"for\");\n        if (!htmlFor) {\n          console.error(\"No 'for' attribute on selected term label\", label);\n          return;\n        }\n        const input = filtersById.get(htmlFor);\n        if (!input) {\n          console.error(\n            `No input found with id ${htmlFor} for selected term label`,\n            label,\n          );\n          return;\n        }\n        input.linkedLabel = label;\n        label.linkedInput = input;\n      });\n\n      // sanity check\n      // TODO: remove in production (as well as other similar checks)\n      filters.forEach((category, categoryName) => {\n        if (category.type === null || category.mainInput === null) {\n          console.error(category);\n          throw new DataBearingError(\n            enableUI,\n            `Incomplete filter category for ${categoryName}`,\n          );\n        }\n      });\n\n      const processedFilters = filters as Map<string, ProcessedFilterCategory>;\n\n      /**\n       * Meat and potatoes\n       *\n       * Here we link clicking on a selected term button with the logic.\n       *\n       * Clicking a term -> Signal is updated -> Signal decides which inputs to check/uncheck\n       * Clicking a selectedTerm -> same\n       *\n       * If the term is part of a checkbox category, we simply toggle it.\n       * If the term is part of a radio category, we uncheck all others and check this one.\n       *\n       * Logic:\n       *\n       * 1. When pressing a selected Filter Button, it unchecks the corresponding input\n       * 2. When pressing a \"clear all\" button, it unchecks all corresponding inputs\n       * 3. When checking/unchecking checkboxes, it updates the \"All\" radio button accordingly\n       * 4. When pressing the \"all\" radio button, it unchecks all corresponding checkboxes\n       * 5. When an input is selected, the corresponding selected term button is shown\n       */\n\n      processedFilters.forEach((category, _categoryName) => {\n        const resetCategoryAndCancelEvent = (event: Event) => {\n          event.preventDefault();\n          category.selected.set(new Set());\n        };\n\n        // add or remove elements from the selected list when inputs change\n        category.collection.forEach((input) => {\n          // make sure to reset state after a page refresh\n          input.checked = false;\n          category.mainInput.checked = true;\n\n          input.addEventListener(\"change\", () => {\n            const selected = category.selected.get();\n            if (input.type === \"radio\") {\n              selected.clear();\n            }\n            if (input.checked) {\n              selected.add(input);\n            } else {\n              selected.delete(input);\n            }\n            category.selected.set(selected, true);\n          });\n\n          // react to selected term button clicks\n          // for checkboxes, we can rely on the `change` event above\n          // but for radios, we need to handle clicks separately\n          if (category.type === \"radio\") {\n            input.linkedLabel.addEventListener(\n              \"click\",\n              resetCategoryAndCancelEvent,\n            );\n          }\n        });\n\n        // reset buttons clicked\n        category.mainInput.addEventListener(\n          \"change\",\n          resetCategoryAndCancelEvent,\n        );\n        category.resetButton?.addEventListener(\n          \"click\",\n          resetCategoryAndCancelEvent,\n        );\n\n        // react to selection changes\n        category.selected.on((newSelected) => {\n          category.mainInput.checked = newSelected.size === 0;\n          category.collection.forEach((input) => {\n            const shouldBeChecked = newSelected.has(input);\n            input.checked = shouldBeChecked;\n            input.linkedLabel.hidden = !shouldBeChecked;\n          });\n        });\n      });\n\n      const resetAll = () => {\n        processedFilters.forEach((category) => {\n          category.selected.set(new Set());\n        });\n      };\n\n      clearAllButton.hidden = true;\n      clearAllButton.addEventListener(\"click\", resetAll);\n\n      activeFiltersMap.on((newMap) => {\n        let anyValueSelected = false;\n        for (const [, values] of newMap) {\n          if (values.size > 0) {\n            anyValueSelected = true;\n            break;\n          }\n        }\n        clearAllButton.hidden = !anyValueSelected;\n      });\n\n      return { ...activeFiltersMap, resetAll };\n    })();\n\n    const getFiltersObject = (): SearchFilters =>\n      Object.fromEntries(activeFiltersMap.get().entries());\n\n    /*********************************************************\n     *\n     * Cards Augmentation\n     *\n     * In order to easily mark cards as search results or not,\n     * we augment them with helper methods.\n     * This is frowned upon in some circles, but no one will\n     * know if we don't tell them.\n     *\n     ********************************************************/\n\n    /**\n     * We augment all cards, JQuery-style, with new methods\n     */\n    const { cards, clearCards } = (() => {\n      const cardAugmentations = {\n        isSearchResult(this: HTMLElement, score: number) {\n          this.classList.add(\"isSearchResult\");\n          this.style.setProperty(\"--search-score\", `${score}`);\n        },\n        isNotSearchResult(this: HTMLElement) {\n          this.classList.remove(\"isSearchResult\");\n          this.style.removeProperty(\"--search-score\");\n        },\n      };\n\n      /**\n       * Appends the `isSearchResult` and `isNotSearchResult` methods to the card element\n       */\n      const augmentCard = (\n        card: HTMLLIElement,\n      ): HTMLLIElement & typeof cardAugmentations =>\n        Object.assign(card, cardAugmentations) as\n          & HTMLLIElement\n          & typeof cardAugmentations;\n\n      /**\n       * Map of all cards, keyed by their slug\n       */\n      const cards = new Map(\n        cardsBeforeAugmentation.map((item) => [\n          item.id.slice(\"card-for-\".length),\n          augmentCard(item),\n        ]),\n      );\n\n      /**\n       * Removes all search results styling from all cards\n       */\n      const clearCards = () =>\n        cards.forEach((card) => card.isNotSearchResult());\n\n      return { cards, clearCards };\n    })();\n\n    /*********************************************************\n     *\n     * Preparing Signals\n     *\n     * Signals are reactive data structures that update automatically\n     * We have:\n     * 1. A signal for the filters state, which updates when any filter input is changed\n     * 2. A signal for the search results, which updates when the search is performed\n     * 3. A signal for the amount of search results, which updates when the search results signal updates\n     * 4. A signal for loading the search data from the JSON file\n     *\n     ********************************************************/\n\n    /**\n     * Records the amount of successful search results and total results\n     */\n    const searchResultsAmountState = Signal<[number, number]>([0, 0]);\n\n    /**\n     * Signal that loads the search data from the JSON file\n     */\n    const searchLoadedDataState = FetcherSignal<SearchIndexData>();\n\n    /*********************************************************\n     *\n     * Preparing the Search Functionality\n     *\n     * Here we:\n     *\n     * 1. Prepare the live search function that runs anytime a filter is changed\n     * 2. Prepare the reactive signals that fire anytime a filter is changed\n     * 3. Prepare the client-side search function that runs when the form is submitted\n     *\n     * They will all then be tied together at the bottom of this file\n     *\n     ********************************************************/\n\n    /**\n     * Main search function.\n     * Called when the search form is submitted\n     * or when the filters are changed\n     * When the text input is changed, filters are cleared.\n     */\n    const onSearchResultsChanged = (results: SearchResult[]) => {\n      clearCards();\n\n      let shown = 0;\n\n      for (let i = 0; i < results.length; i++) {\n        const { item, score } = results[i];\n        const card = cards.get(item.slug);\n        if (!card) {\n          console.error(`Element not found for slug: ${item.slug}`);\n          continue;\n        }\n        card.isSearchResult(score);\n        card.style.order = String(i);\n        shown += 1;\n      }\n\n      searchResultsAmountState.set([shown, searchResultsAmountState.get()[1]]);\n    };\n\n    /**\n     * Updates the summary element that shows the amount of results found\n     */\n    const onSearchAmountChanged = ([amountOfValidResults, total]: [\n      number,\n      number,\n    ]) => {\n      const noResultsClass = \"noResult\";\n      if (total === 0) {\n        document.body.classList.remove(noResultsClass);\n        replace(summary, span(\"\"));\n      } else if (amountOfValidResults === 0) {\n        document.body.classList.add(noResultsClass);\n        const hasAppliedFilters = activeFiltersMap.get().size > 0;\n        const searchString = searchInput.value.trim();\n        if (!hasAppliedFilters && searchString === \"\") {\n          replace(summary, span(\"All results\"));\n          return;\n        }\n        const keywords: string[] = [];\n        activeFiltersMap\n          .get()\n          .forEach((values) => values.forEach((value) => keywords.push(value)));\n        if (searchString !== \"\") {\n          keywords.push(searchString);\n        }\n        replace(\n          summary,\n          span(\n            em(\"No results yet! \"),\n            a(\n              {\n                href: `https://school.gdquest.com/about-us/contact?subject=${\n                  encodeURIComponent(\n                    \"Suggest an article\",\n                  )\n                }`,\n              },\n              \"Suggest a subject\",\n            ),\n          ),\n        );\n      } else {\n        document.body.classList.remove(noResultsClass);\n        replace(\n          summary,\n          span({ className: \"keyword\" }, amountOfValidResults),\n          span(` result${amountOfValidResults === 1 ? \"\" : \"s\"} out of `),\n          a(\n            { href: \"/library/search#CardSearch\", className: \"keyword\" },\n            total,\n          ),\n        );\n      }\n    };\n\n    /**\n     * Called after the search data is loaded from the json file.\n     * Takes care of setting events handlers on the form\n     * @param data Data loaded from the search index JSON file\n     */\n    const onSearchDataLoaded = (data: SearchIndexData) => {\n      const { items } = data;\n      const total = items.length;\n      searchResultsAmountState.set([total, total]);\n      const engine = createLibrarySearchEngine(items);\n\n      const runSearch = (\n        query: string,\n        filters: SearchFilters,\n      ): SearchResult[] => engine.search(query, { filters });\n\n      const currentQueryState = Signal(\"\");\n\n      const updateResults = () => {\n        const query = currentQueryState.get();\n        const filters = getFiltersObject();\n        const hasQuery = query.length > 0;\n        const hasFilters = Object.values(filters).some((s) => s.size > 0);\n\n        if (!hasQuery && !hasFilters) {\n          gridList.classList.remove(\"isFiltered\");\n          clearCards();\n          searchResultsAmountState.set([total, total]);\n          return;\n        }\n\n        gridList.classList.add(\"isFiltered\");\n        const results = runSearch(query, filters);\n        onSearchResultsChanged(results);\n      };\n\n      const setQuery = (\n        searchPattern?: string | null,\n        { updateHistory = true } = {},\n      ) => {\n        const query = typeof searchPattern === \"string\"\n          ? searchPattern.trim()\n          : \"\";\n\n        currentQueryState.set(query);\n        searchInput.value = query;\n\n        if (updateHistory) {\n          if (query === \"\") {\n            globalThis.history.replaceState(\n              null,\n              \"\",\n              globalThis.location.pathname,\n            );\n          }\n        }\n        suggestions?.clear();\n        updateResults();\n      };\n\n      const suggestions = suggestionsContainer\n        ? createSuggestionsDropdown({\n          classPrefix,\n          container: suggestionsContainer,\n          input: searchInput,\n          onSelect: (value: string) => {\n            activeFiltersMap.resetAll();\n            setQuery(value);\n          },\n        })\n        : null;\n\n      const updateSuggestions = suggestions\n        ? debounce(() => {\n          const query = searchInput.value.trim();\n          if (query.length < 2) {\n            suggestions.clear();\n            return;\n          }\n          const nextSuggestions = engine.suggest(query);\n          suggestions.render(nextSuggestions);\n        }, 120)\n        : null;\n\n      if (suggestions && updateSuggestions) {\n        searchInput.addEventListener(\"input\", () => {\n          updateSuggestions();\n        });\n        searchInput.addEventListener(\"keydown\", (event) => {\n          if (suggestions.handleKey(event)) {\n            event.preventDefault();\n          }\n        });\n      }\n\n      searchForm.addEventListener(\"submit\", (e) => {\n        e.preventDefault();\n        const query = new FormData(searchForm).get(\"search\");\n        if (typeof query !== \"string\") {\n          return;\n        }\n        activeFiltersMap.resetAll();\n        globalThis.history.replaceState(\n          null,\n          \"\",\n          `?search=${encodeURIComponent(query)}`,\n        );\n        setQuery(query, { updateHistory: false });\n      });\n\n      const { search: searchQuery = false } = pick(\n        searchParamsToObj(globalThis.location.search, {\n          single: true,\n          joinArrayChar: false,\n        }),\n        [\"search\"],\n      );\n\n      if (searchQuery !== false && searchQuery.length > 0) {\n        setQuery(searchQuery, { updateHistory: false });\n      }\n\n      activeFiltersMap.on(() => updateResults());\n    };\n\n    type SearchIndexData = {\n      items: SearchableItem[];\n      metadata: {\n        version: number;\n        generatedAt: string;\n      };\n    };\n\n    searchLoadedDataState.on(({ status, data }) => {\n      if (status === \"success\") {\n        onSearchDataLoaded(data);\n        enableUI();\n      } else {\n        console.error(\"Failed to load search data with status\", status, data);\n      }\n    });\n\n    searchResultsAmountState.on(onSearchAmountChanged);\n\n    searchLoadedDataState.load(dataURL);\n  },\n  {\n    onError: (error) => {\n      if (\n        error instanceof DataBearingError &&\n        typeof error.data === \"function\"\n      ) {\n        const restoreUI = error.data;\n        console.error(\"Error setting up main search component:\", error.message);\n        restoreUI();\n      } else {\n        throw error;\n      }\n    },\n  },\n);\n", "import {\n  h,\n  processDomElementOnce,\n} from \"../clientScript/clientDependencies.ts\";\n\nconst { add, button, div, span } = h;\n\ninterface PasswordButton extends HTMLButtonElement {\n  buttonLabel: HTMLSpanElement;\n  setText: (text: string) => void;\n}\n\nfunction setPasswordButtonText(this: PasswordButton, text: string) {\n  this.buttonLabel.textContent = text;\n}\n\nfunction onPasswordButtonClick(this: PasswordButton, _event: MouseEvent) {\n  const controlId = this.getAttribute(\"aria-controls\");\n  const element = document.querySelector<HTMLInputElement>(`#${controlId}`);\n\n  if (!element) {\n    return;\n  }\n\n  const expanded = this.getAttribute(\"aria-expanded\") === \"false\";\n  element.type = expanded ? \"text\" : \"password\";\n  this.setAttribute(\"aria-expanded\", String(expanded));\n  this.setText(expanded ? \"hide characters\" : \"show characters\");\n}\n\nprocessDomElementOnce('input[type=\"password\"]', (input: HTMLInputElement) => {\n  const id = input.getAttribute(\"id\");\n  if (!id) {\n    return;\n  }\n\n  const buttonLabel = span(null, \"show characters\");\n\n  const revealButton = Object.assign(\n    // @ts-expect-error The button is not yet cast to a PasswordButton on this line\n    button({\n      class: \"passwordContainerRevealButton\",\n      ariaExpanded: \"false\",\n      type: \"button\",\n      ariaControls: id,\n      onclick: onPasswordButtonClick,\n    }, buttonLabel),\n    { buttonLabel, setText: setPasswordButtonText },\n  ) as PasswordButton;\n\n  const container = div({\n    class: [\"passwordContainer\", \"inputContainer\"],\n  });\n\n  input.parentElement?.insertBefore(container, input);\n  add(container, input, revealButton);\n});\n", "// if there are multiple promoGDSchool components, mark the one in the margin so it gets hidden\n// on small screens\n(() => {\n  document.querySelectorAll(\".promoGDSchool\").length > 1 &&\n    document\n      .querySelector(\".itemPageMeta .itemPageMetaPromoGDSchoolStarterKit\")\n      ?.classList.add(\"hideOnMobile\");\n})();\n", "import {\n  h,\n  userMessagesCollection,\n  type UserMessageType,\n} from \"../clientScript/clientDependencies.ts\";\n\nconst { add, button, div, span } = h;\n\nconst classPrefix = \"userMessage\";\n\nconst container = div({ class: `${classPrefix}sPane` });\n\nadd(\n  document.body,\n  div(\n    {\n      class: `${classPrefix}s`,\n    },\n    container,\n  ),\n);\n\nconst addUserMessageElement = (\n  id: string,\n  message: string,\n  type: UserMessageType,\n) => {\n  const popup = div(\n    {\n      role: \"alert\",\n      ariaLive: \"assertive\",\n      ariaAtomic: \"true\",\n      id,\n      class: [classPrefix, `${classPrefix}--${type}`],\n    },\n    div(null, message),\n    button(\n      {\n        ariaControls: id,\n      },\n      span(null, \"Close\"),\n    ),\n  );\n\n  add(container, popup);\n};\n\ncontainer.addEventListener(\"click\", (event) => {\n  const target = event.target as HTMLElement;\n  if (target.tagName === \"BUTTON\") {\n    const id = target.getAttribute(\"aria-controls\");\n    id && userMessagesCollection().remove(id);\n  }\n});\n\n// we wait for the animation to end before removing the element\ncontainer.addEventListener(\"animationend\", (event) => {\n  const target = event.target as HTMLElement;\n  if (target.classList.contains(`${classPrefix}Closing`)) {\n    target.remove();\n  }\n});\n\nuserMessagesCollection()\n  .entries()\n  .forEach(([id, { message, type }]) =>\n    addUserMessageElement(id, message, type)\n  );\n\nuserMessagesCollection().onMessageAdded((id, { message, type }) =>\n  addUserMessageElement(id, message, type)\n);\n\nuserMessagesCollection().onMessageRemoved((id) =>\n  document.getElementById(id)?.classList.add(`${classPrefix}Closing`)\n);\n", "import {\n  debounce,\n  makeLogger,\n  processDomElementOnce,\n} from \"../clientScript/clientDependencies.ts\";\n\nconst logger = makeLogger(\"ScrollingList\");\n\n/**\n * Enhances a grid container with slider functionality\n * @param slider the main container element\n */\nprocessDomElementOnce(\".scrollingList\", (slider: Element) => {\n  const grid = slider.querySelector<HTMLElement>(\".gridItemsList\");\n  const controls = slider.querySelector<HTMLElement>(\".scrollingListControls\");\n  const prevButton = slider.querySelector<HTMLButtonElement>(\n    \".scrollingListControlsPrevious\",\n  );\n  const nextButton = slider.querySelector<HTMLButtonElement>(\n    \".scrollingListControlsNext\",\n  );\n\n  if (!grid || !controls || !prevButton || !nextButton) {\n    logger.warn(\n      \"ScrollingList: Missing required elements. Ensure the grid and controls are present.\",\n      { grid, controls, prevButton, nextButton },\n    );\n    return;\n  }\n\n  let carouselWindowWidth = 0;\n  let pages = 0;\n  let currentPage = 0;\n\n  const init = () => {\n    controls.removeAttribute(\"hidden\");\n    slider.classList.add(\"isScrolling\");\n    slider.ariaRoleDescription = \"carousel\";\n\n    prevButton.addEventListener(\"click\", () => navigate(-1));\n    nextButton.addEventListener(\"click\", () => navigate(1));\n\n    globalThis.addEventListener(\"resize\", debounce(calculateAndNavigate));\n\n    grid.addEventListener(\"scrollend\", calculateDimensions);\n\n    calculateDimensions();\n  };\n\n  const calculateDimensions = () => {\n    carouselWindowWidth = grid.offsetWidth;\n    const carouselInnerWidth = grid.scrollWidth;\n    pages = Math.ceil(carouselInnerWidth / carouselWindowWidth);\n    currentPage = Math.ceil(grid.scrollLeft / carouselWindowWidth);\n    updateButtons();\n  };\n\n  const navigate = (direction: number) => {\n    const nextPage = (currentPage + direction) % pages;\n    navigateToPage(nextPage);\n  };\n\n  const navigateToPage = (pageNumber: number) => {\n    currentPage = pageNumber;\n    grid.scrollLeft = pageNumber * carouselWindowWidth;\n    updateButtons();\n  };\n\n  const calculateAndNavigate = () => {\n    calculateDimensions();\n    navigateToPage(currentPage);\n  };\n\n  const updateButtons = () => {\n    prevButton.disabled = currentPage === 0;\n    nextButton.disabled = currentPage === pages - 1;\n  };\n\n  init();\n});\n", "import {\n  type AdvancedMechanicsNodeInput,\n  h,\n} from \"../clientScript/clientDependencies.ts\";\n\nconst {\n  p,\n  span,\n  ul,\n  li,\n  div,\n  h4,\n  h3,\n} = h;\n\nconst classPrefix = \"nodeFlashCard\";\n\nconst iconsNamesMap: Record<string, string> = {\n  Navigation2D: \"NavigationAgent2D\",\n  Navigation3D: \"NavigationAgent3D\",\n  CSG: \"CSGBox3D\",\n  Light2D: \"DirectionalLight2D\",\n  Light3D: \"DirectionalLight3D\",\n};\n\nconst getIconPath = (name: string) => {\n  const iconName = iconsNamesMap[name] ?? name;\n  return `./icons/godot/${iconName}.svg`;\n};\n\n// TODO: image paths and data path are relative. This is fine because this element\n// is only used in the Node Flashcard Shuffler, which is on the front page and has a\n// known, static path.\n// If we ever use this component outside of the shuffler, we need to make the paths\n// absolute, by passing a base URL to the component somehow.\n\nexport const NodeFlashCard = (\n  { category, title, use_when, examples, name }: AdvancedMechanicsNodeInput,\n) =>\n  li(\n    { className: [classPrefix, `${classPrefix}Category-${category}`] },\n    div(\n      { className: `${classPrefix}Header` },\n      h3({ className: `${classPrefix}HeaderTitle` }, name),\n      div({\n        className: `${classPrefix}HeaderIcon`,\n        style: { \"--node-icon\": `url(${getIconPath(name)})` },\n      }),\n    ),\n    div(\n      { className: `${classPrefix}Body` },\n      span({ className: `${classPrefix}Badge` }, category),\n      p(\n        { className: `${classPrefix}ShortDescription` },\n        title,\n      ),\n      div(\n        { className: `${classPrefix}Usage` },\n        h4({ className: `${classPrefix}UsageTitle` }, \"USE IT WHEN\"),\n        p(\n          { className: `${classPrefix}UsageText` },\n          use_when,\n        ),\n      ),\n      div(\n        { className: `${classPrefix}Examples` },\n        h4({ className: `${classPrefix}ExamplesTitle` }, \"EXAMPLES\"),\n        ul(\n          { className: `${classPrefix}ExamplesList`, role: \"list\" },\n          ...examples.map((example) => li(example)),\n        ),\n      ),\n    ),\n  );\n", "import {\n  type AdvancedMechanicsNodeInput,\n  FetcherSignal,\n  getClampedRandomInt,\n  h,\n  processDomElementOnce,\n  shuffleArray,\n} from \"../clientScript/clientDependencies.ts\";\nimport { NodeFlashCard } from \"./NodeFlashCard.client.ts\";\n\nconst { replace } = h;\n\nconst nodeEssentialsData = FetcherSignal<{\n  list: AdvancedMechanicsNodeInput[];\n}>();\n\nprocessDomElementOnce<HTMLElement>(\".nodeFlashCardShuffler\", (element) => {\n  const contentPane = element.querySelector<HTMLElement>(\n    \".nodeFlashCardShufflerContentPane\",\n  );\n  const buttons = element.querySelectorAll<HTMLElement>(\n    \"button.nodeFlashCardShufflerButton\",\n  );\n  const grid = element.querySelector<HTMLElement>(\".nodeFlashCardShufflerGrid\");\n\n  if (!contentPane || !grid) {\n    console.error(\"Missing required elements for Node Flashcard Shuffler\");\n    return;\n  }\n\n  const dataURL = element.dataset.nodesUrl;\n  if (!dataURL) {\n    console.error(\"No data URL found for Node Flashcard Shuffler\");\n    return;\n  }\n\n  const setStateLoading = (loading: boolean) => {\n    contentPane.setAttribute(\"aria-busy\", loading ? \"true\" : \"false\");\n    buttons.forEach((button) =>\n      loading\n        ? button.setAttribute(\"disabled\", \"\")\n        : button.removeAttribute(\"disabled\")\n    );\n  };\n\n  grid.addEventListener(\"animationend\", () => grid.classList.remove(\"slideIn\"));\n\n  const data: AdvancedMechanicsNodeInput[] = [];\n  let currentIndex = 0;\n\n  const pickThreeNextCards = () => {\n    if (data.length === 0) {\n      return;\n    }\n    setStateLoading(false);\n    const nextIndex = currentIndex + 3;\n    if (nextIndex >= data.length) {\n      currentIndex = 0; // reset index to loop through the data again\n      assignNodeData();\n    }\n    const nextCards = data.slice(currentIndex, nextIndex);\n    currentIndex = nextIndex;\n    replace(grid, ...nextCards.map(NodeFlashCard));\n    grid.classList.add(\"slideIn\");\n  };\n\n  const fakeLoadAndPickThree = () => {\n    setStateLoading(true);\n    setTimeout(pickThreeNextCards, getClampedRandomInt(300, 1000));\n  };\n\n  const onClick = (_event: MouseEvent) => {\n    if (contentPane.getAttribute(\"aria-busy\") === \"true\") {\n      return;\n    }\n    fakeLoadAndPickThree();\n  };\n\n  const assignNodeData = () => {\n    const incomingData = nodeEssentialsData.data();\n    if (!incomingData) {\n      return;\n    }\n    data.length = 0; // clear previous data\n    data.push(...shuffleArray(incomingData.list));\n    // duplicate items at the end if the length is not a multiple of 3\n    const remainder = data.length % 3;\n    if (remainder !== 0) {\n      const itemsToAdd = 3 - remainder;\n      const lastItems = data.slice(-itemsToAdd);\n      data.push(...lastItems);\n    }\n  };\n\n  nodeEssentialsData.on(({ status }) => {\n    if (status !== \"success\") {\n      setStateLoading(true);\n    } else {\n      assignNodeData();\n      pickThreeNextCards();\n      setStateLoading(false);\n    }\n  });\n\n  buttons.forEach((button) => button.addEventListener(\"click\", onClick));\n\n  setStateLoading(true);\n  nodeEssentialsData.load(dataURL);\n});\n", "// import { processClapsButton } from \"./clapsButton.ts\";\n\ndocument.querySelectorAll(\".itemSummaryBrowser\").forEach((element) => {\n  const randomButton = element.querySelector(\n    \"button.itemSummaryBrowserRandomButton\",\n  ) as HTMLButtonElement | null;\n\n  randomButton?.addEventListener(\"click\", () => {\n    element.setAttribute(\"aria-busy\", \"true\");\n    // simulate a delay\n    setTimeout(() => element.setAttribute(\"aria-busy\", \"false\"), 1000);\n  });\n});\n", "import {\n  autoFetchWhenSubmit,\n  type MailSubscriptionRequestFormResponse,\n  processDomElementOnce,\n} from \"../clientScript/clientDependencies.ts\";\n\nprocessDomElementOnce(\n  `form[data-is=\"mailingListCollector\"]`,\n  (form: HTMLFormElement) => {\n    const messagesContainer = form.querySelector<HTMLElement>(\"[aria-live]\");\n    if (!messagesContainer) {\n      console.error(`there's no announcement field in this mailing list form`);\n      return;\n    }\n    const messages = Array.from(messagesContainer.querySelectorAll(\"span\"));\n    if (messages.length < 3) {\n      console.error(`missing message elements in this mailing list form`);\n      return;\n    }\n    const [messageAlreadySubscribed, messageSuccess, messageError] = messages\n      .map((element) => {\n        const newElement = element.cloneNode(true) as HTMLSpanElement;\n        newElement.removeAttribute(\"aria-hidden\");\n        newElement.removeAttribute(\"hidden\");\n        newElement.textContent = element.textContent;\n        element.remove();\n        return () => {\n          messagesContainer.innerHTML = \"\";\n          messagesContainer.append(newElement);\n        };\n      });\n    const jsonInput = form.querySelector<HTMLInputElement>(\n      'input[type=\"hidden\"][name=\"json\"]',\n    );\n    if (jsonInput) {\n      jsonInput.value = \"true\";\n    }\n    const onSubmit = autoFetchWhenSubmit({\n      method: \"POST\",\n      doDisableForm: true,\n      doReEnableForm: 500,\n      callback: async (err, result) => {\n        if (err || !result) {\n          console.error(err, result);\n          messageError();\n          return;\n        }\n        const data = await result.json() as MailSubscriptionRequestFormResponse;\n        switch (data.code) {\n          case 200:\n            messageAlreadySubscribed();\n            break;\n          case 201:\n            messageSuccess();\n            break;\n          default:\n            messageError();\n        }\n      },\n    });\n    form.addEventListener(\"submit\", onSubmit);\n  },\n);\n", "export const classPrefix = \"tableOfContents\";\nexport const BUTTON_TEXT_CLOSED = \"unfold subheadings\";\nexport const BUTTON_TEXT_OPEN = \"fold subheadings\";\nexport const CLASS_HAS_CHILDREN = \"hasSubheadings\";\nexport const CLASS_ANCHOR_SCROLLED_PAST = \"isActive\";\nexport const CLASS_CURRENT_LIST_ITEM = \"isCurrent\";\nexport const CLASS_SUBHEADINGS_LIST = classPrefix + \"SubheadingsList\";\nexport const CLASS_SUBHEADINGS_LIST_CONTAINER = classPrefix +\n  \"SubheadingsContainer\";\nexport const CLASS_ANCHOR_LINK = classPrefix + \"Anchor\";\nexport const CLASS_ANCHOR_LINK_LEVEL_PREFIX = classPrefix + \"AnchorLinkTo\";\nexport const CLASS_LIST_ITEM = classPrefix + \"ListItem\";\nexport const CLASS_LIST_ITEM_LEVEL_PREFIX = classPrefix + \"ItemLevel\";\nexport const CLASS_FOLD_UNFOLD_BUTTON = classPrefix + \"FoldUnfoldButton\";\nexport const SIDEBAR_CLOSED_BODY_CLASS = `${classPrefix}SideBarIsClosed`;\nexport const CLASS_SCROLLING_PANE = `${classPrefix}Pane`;\n", "// Determines the viewport size based on CSS media queries by reading the content of the body:before pseudo-element.\n// see: web-components/clientStyles/contentGrid.scss\ntype ViewPortSize =\n  | \"viewport-mobile\"\n  | \"viewport-tablet\"\n  | \"viewport-desktop\";\n\n/**\n * Determines if the page is being viewed on mobile, tablet, or desktop.\n * To avoid trying to sync with CSS media queries in multiple places,\n * this function reads the `content` property of the `body:before` pseudo-element,\n * which is set via CSS media queries.\n *\n * This of course requires that the CSS is set up to do this. Something like:\n * ```css\n * &::before {\n * \tcontent: \"viewport-small\";\n * }\n * @media (min-width: $tablet-breakpoint) {\n * \t&::before {\n * \t\tcontent: \"viewport-tablet\";\n * \t}\n * }\n * @media (min-width: $mid-breakpoint) {\n *   ... and so on\n * ```\n * If the CSS is not set up this way, the function falls back to a simple\n * media query based on the `fallBackMaxWidth` parameter.\n *\n * @param fallBackMaxWidth - The max width in pixels to consider as mobile for the fallback media query. Default is 1080.\n */\nexport const getViewPortSizeFromCss = (\n  fallBackMaxWidth = 1080,\n): ViewPortSize => {\n  const size = (getComputedStyle(document.body, \":before\")?.getPropertyValue(\n    \"content\",\n  ) ?? \"\").slice(1, -1).trim() as\n    | \"viewport-mobile\"\n    | \"viewport-tablet\"\n    | \"viewport-desktop\"\n    | \"\"\n    | undefined;\n\n  if (!size) {\n    // fallback to media query -- this should match the ContentGrid queries\n    if (globalThis.matchMedia(`(max-width: ${fallBackMaxWidth}px)`).matches) {\n      return \"viewport-mobile\";\n    }\n    return \"viewport-desktop\";\n  }\n  return size;\n};\n", "import * as constants from \"./tableOfContentsConsts.ts\";\nimport type { ToggleShowEvent } from \"./togglerButton.client.ts\";\nimport {\n  onScrollStopped,\n  processDomElementOnce,\n  scrollIntoViewIfPartiallyVisible,\n} from \"../clientScript/clientDependencies.ts\";\nimport { getViewPortSizeFromCss } from \"../clientScript/getViewPortSizeFromCss.ts\";\n\ntype HeadingAnchor = HTMLAnchorElement & {\n  heading: HTMLElement;\n  closestRevealButton?: HTMLButtonElement | null;\n  setIsScrolledPast: (isScrolledPast: boolean) => void;\n  setIsCurrent: (isCurrent: boolean) => void;\n  scrollingParent: HTMLElement;\n  root: HTMLElement;\n};\n\nfunction setIsScrolledPast(this: HeadingAnchor, isScrolledPast: boolean) {\n  if (isScrolledPast) {\n    this.classList.add(constants.CLASS_ANCHOR_SCROLLED_PAST);\n  } else {\n    this.classList.remove(constants.CLASS_ANCHOR_SCROLLED_PAST);\n  }\n}\n\nfunction setIsCurrent(this: HeadingAnchor, isCurrent: boolean) {\n  const parent = this.parentElement as HTMLLIElement;\n  if (isCurrent) {\n    parent.classList.add(constants.CLASS_CURRENT_LIST_ITEM);\n    scrollIntoViewIfPartiallyVisible(parent, this.scrollingParent);\n    const revealButton = this.closestRevealButton;\n    if (\n      revealButton && revealButton.getAttribute(\"aria-expanded\") === \"false\"\n    ) {\n      revealButton.click();\n    }\n  } else {\n    parent.classList.remove(constants.CLASS_CURRENT_LIST_ITEM);\n  }\n}\n\nconst sortDomElementsByVerticalPosition = (a: string, b: string) =>\n  (document.getElementById(a)?.getBoundingClientRect().top ?? 0) -\n  (document.getElementById(b)?.getBoundingClientRect().top ?? 0);\n\nconst getDirectChildButton = (element: HTMLElement | null) => {\n  return element &&\n    (Array.from(element.children).find((child) =>\n      child.matches(\n        `button.${constants.CLASS_FOLD_UNFOLD_BUTTON}`,\n      )\n    ) as HTMLButtonElement | null);\n};\n\nprocessDomElementOnce('[data-is=\"article-toc\"]', (root: HTMLElement) => {\n  /** All observed headings */\n  const headings: HTMLHeadingElement[] = [];\n  /** List of all headings ids */\n  const headingsIds: string[] = [];\n  const anchors = new Map<string, HeadingAnchor>();\n\n  const scrollingParent = root.closest<HTMLElement>(\n    `.${constants.CLASS_SCROLLING_PANE}`,\n  );\n\n  if (!scrollingParent) {\n    throw new Error(\"Scrolling parent not found\");\n  }\n\n  const removeAllCurrent = () =>\n    root\n      .querySelectorAll(`.${constants.CLASS_CURRENT_LIST_ITEM}`)\n      .forEach((el) => el.classList.remove(constants.CLASS_CURRENT_LIST_ITEM));\n\n  let suspendObserverUpdates = false;\n\n  function anchorClicked(this: HeadingAnchor) {\n    removeAllCurrent();\n    setIsCurrent.call(this, true);\n    suspendObserverUpdates = true;\n    onScrollStopped(() => {\n      suspendObserverUpdates = false;\n      setIsCurrent.call(this, true); // this needs to be called again because of a race between scroll stopped and observer\n    });\n  }\n\n  root.querySelectorAll<HeadingAnchor>(\n    `a.${constants.CLASS_ANCHOR_LINK}[href^=\"#\"]`,\n  )\n    .forEach((anchor) => {\n      const href = anchor.getAttribute(\"href\");\n      if (!href) return;\n      const heading = document.querySelector<HTMLHeadingElement>(href);\n      if (!heading) return;\n      const id = href.slice(1);\n      headingsIds.push(id);\n      headings.push(heading);\n      anchor.heading = heading;\n      anchors.set(id, anchor);\n      anchor.setIsScrolledPast = setIsScrolledPast;\n      anchor.setIsCurrent = setIsCurrent;\n      anchor.scrollingParent = scrollingParent;\n      anchor.addEventListener(\"click\", anchorClicked);\n    });\n\n  const revealButtons = new Set<HTMLButtonElement>();\n\n  anchors.forEach((anchor) => {\n    let currentElement: HTMLLIElement | null | undefined = anchor\n      .parentElement as HTMLLIElement;\n    while (currentElement) {\n      const revealButton = getDirectChildButton(currentElement);\n      if (revealButton != null) {\n        anchor.closestRevealButton = revealButton;\n        revealButtons.add(revealButton);\n        return;\n      }\n      currentElement = currentElement.parentElement?.closest(\"li\");\n    }\n  });\n\n  /** list of active headings ids */\n  const active: string[] = [];\n\n  const observer = new IntersectionObserver(\n    (entries) => {\n      // collect headings in view\n      entries.forEach((entry) => {\n        if (entry.isIntersecting && entry.intersectionRatio > 0) {\n          active.push(entry.target.id);\n        } else {\n          const index = active.indexOf(entry.target.id);\n          if (index > -1) {\n            active.splice(index, 1);\n          }\n        }\n      });\n\n      // if no headings are active, exit early\n      if (active.length === 0) {\n        return;\n      }\n      // get the highest in viewport\n      const primaryActiveId = active.sort(sortDomElementsByVerticalPosition).at(\n        0,\n      );\n\n      let reachedCurrent = false;\n\n      if (suspendObserverUpdates === false) {\n        removeAllCurrent();\n      }\n\n      for (const [id, anchor] of anchors) {\n        if (reachedCurrent || id === primaryActiveId) {\n          if (id === primaryActiveId) {\n            reachedCurrent = true;\n            anchor.setIsScrolledPast(true);\n            if (suspendObserverUpdates === false) {\n              anchor.setIsCurrent(true);\n            }\n          } else {\n            anchor.setIsScrolledPast(false);\n          }\n        } else {\n          anchor.setIsScrolledPast(true);\n        }\n      }\n    },\n    { rootMargin: \"0% 0% -10% 0%\" },\n  );\n  headings.forEach((h) => observer.observe(h));\n});\n\nprocessDomElementOnce(\n  `#${constants.classPrefix}Wrapper button.${constants.classPrefix}ToggleButton`,\n  (button: HTMLButtonElement) => {\n    // By default, the navigation is shown until the toggle is pressed, but on mobile,\n    // the navigation is hidden by default.\n    // We will do a media query that checks if there's enough space for the navigation to be shown.\n    // If not, we programmatically press the toggle button to hide the navigation.\n\n    const target = document.getElementById(\n      button.getAttribute(\"aria-controls\")!,\n    );\n\n    if (!target) {\n      return;\n    }\n    button.addEventListener(\"toggler-toggleshow\", (event: ToggleShowEvent) => {\n      document.documentElement.classList.toggle(\n        constants.SIDEBAR_CLOSED_BODY_CLASS,\n        event.isHidden,\n      );\n    });\n\n    // trick to get CSS to tell it size; the `content` property of the\n    // `after` pseudo-element is changed depending on media queries.\n    const size = getViewPortSizeFromCss();\n    if (size === \"viewport-mobile\") {\n      button.click();\n    }\n  },\n);\n", "import { processDomElementOnce } from \"../clientScript/clientDependencies.ts\";\n\ninterface Tab extends HTMLAnchorElement {\n  panel: HTMLElement;\n}\n\nfunction augmentTabList(tabList: HTMLElement) {\n  let tabFocus = -1;\n  const cache = new Map<string, number>();\n\n  const tabs = (\n    Array.from(tabList.querySelectorAll<Tab>('a[href^=\"#\"][role=\"tab\"]'))\n  ).reduce((tabs: Tab[], tab, index) => {\n    const controlledId = tab.getAttribute(\"aria-controls\");\n    if (!controlledId || !tab.hash) {\n      return tabs;\n    }\n    const controlledElement = document.getElementById(controlledId);\n    if (!controlledElement) {\n      return tabs;\n    }\n    if (tab.getAttribute(\"aria-selected\") === \"true\") {\n      tabFocus = index;\n    }\n    cache.set(tab.hash, index);\n    tab.panel = controlledElement;\n    tabs.push(tab);\n    return tabs;\n  }, []);\n\n  const setCurrentTabFromFocus = () => {\n    const tab = tabs[tabFocus];\n    if (!tab) {\n      return;\n    }\n    tabs.forEach((t) => {\n      if (t == tab) {\n        return;\n      }\n      t.setAttribute(\"aria-selected\", \"false\");\n      t.setAttribute(\"tabindex\", \"-1\");\n      t.panel.setAttribute(\"aria-hidden\", \"true\");\n      t.panel.setAttribute(\"hidden\", \"true\");\n    });\n    tab.setAttribute(\"aria-selected\", \"true\");\n    tab.setAttribute(\"tabindex\", \"0\");\n    tab.panel.setAttribute(\"aria-hidden\", \"false\");\n    tab.panel.removeAttribute(\"hidden\");\n  };\n\n  const tabNext = () => (tabFocus === tabs.length - 1 ? 0 : tabFocus + 1);\n\n  const tabPrevious = () => (tabFocus === 0 ? tabs.length - 1 : tabFocus - 1);\n\n  const setNewTabFocus = (newFocus: number) => {\n    if (newFocus === tabFocus) {\n      return;\n    }\n    tabs[tabFocus]?.setAttribute(\"tabindex\", \"-1\");\n    tabFocus = newFocus;\n    tabs[tabFocus]?.setAttribute(\"tabindex\", \"0\");\n    tabs[tabFocus]?.focus();\n  };\n\n  tabList.addEventListener(\"keydown\", (e: KeyboardEvent) => {\n    if (e.key === \"ArrowRight\" || e.key === \"ArrowLeft\") {\n      const newFocus = e.key === \"ArrowRight\" ? tabNext() : tabPrevious();\n      setNewTabFocus(newFocus);\n    }\n  });\n\n  function onHashChange() {\n    const index = cache.get(location.hash);\n    if (index == null) {\n      return;\n    }\n    tabFocus = index;\n    setCurrentTabFromFocus();\n  }\n\n  if (tabFocus === -1) {\n    tabFocus = 0;\n  }\n\n  globalThis.addEventListener(\"hashchange\", onHashChange);\n  setCurrentTabFromFocus();\n  onHashChange();\n}\n\nprocessDomElementOnce('[role=\"tablist\"]', augmentTabList);\n", "document.querySelectorAll<HTMLButtonElement>('button[data-is=\"theme-toggle\"]')\n  .forEach((button) => {\n    button.addEventListener(\"click\", () => {\n      const isDark = document.documentElement.classList.toggle(\"dark\");\n      localStorage.setItem(\"theme\", isDark ? \"dark\" : \"light\");\n    });\n  });\n", "document.querySelectorAll<HTMLVideoElement>(\"video[data-should-preload]\")\n  .forEach((video) => {\n    const condition = video.getAttribute(\"data-should-preload\");\n    switch (condition) {\n      case \"onmouseenter\":\n        video.addEventListener(\"mouseenter\", () => {\n          video.preload = \"auto\";\n        });\n        break;\n    }\n  });\n", "import {\n  h,\n  processDomElementOnce,\n} from \"../clientScript/clientDependencies.ts\";\n\nconst { a, span, add } = h;\n\nconst pageTitle = (document.body.querySelector(\"main h1\")?.textContent ?? \"\")\n  .trim();\nconst pageUrl = new URL(globalThis.location.href);\npageUrl.hash = \"\";\n\nprocessDomElementOnce<HTMLElement>(\n  `main.prose h1, main.prose h2, main.prose h3`,\n  (element) => {\n    const anchor = element.id;\n    if (!anchor) return;\n    element.classList.add(\"anchorClipboardButtonInvoker\");\n    const title = element.textContent?.trim() ?? \"\";\n    const dataClipboard = `${pageTitle} - ${title}: ${pageUrl}#${anchor}`;\n    const clipboardButton = a({\n      className: `anchorClipboardButton`,\n      dataIs: \"clipboard-button\",\n      href: `#${anchor}`,\n      dataClipboard,\n    }, span(`Click to copy`));\n    clipboardButton.addEventListener(\"click\", (event) => {\n      event.preventDefault();\n      if (history.pushState) history.pushState(null, \"unused\", `#${anchor}`);\n    });\n    add(element, clipboardButton);\n  },\n  `js-processed-anchorClipboardButtonInvoker`,\n);\n", "import { processDomElementOnce } from \"../clientScript/clientDependencies.ts\";\n\nfunction unclickButton(button: HTMLButtonElement) {\n  button.setAttribute(\"aria-pressed\", \"false\");\n}\n\nfunction onclipboardButtonClick(this: HTMLButtonElement, _event: Event) {\n  const value = this.getAttribute(\"data-clipboard\");\n  const clipboard = value === \"currentURL\" || value == null\n    ? globalThis.location.href\n    : value;\n  navigator.clipboard.writeText(clipboard);\n  this.setAttribute(\"aria-pressed\", \"true\");\n\n  setTimeout(() => unclickButton(this), 2000);\n}\n\nconst processClipboardButton = (button: HTMLButtonElement) => {\n  button.addEventListener(\"click\", onclipboardButtonClick);\n};\n\nprocessDomElementOnce(\n  \"[data-is='clipboard-button']\",\n  processClipboardButton,\n);\n", "import { Signal } from \"./clientDependencies.ts\";\n\ninterface ScrollSpyOptions {\n  scrollElement: HTMLElement | Document;\n  granularity?: number;\n  debounceDelay?: number;\n}\n\nconst createScrollSpy = (\n  { scrollElement, granularity = 10 }: ScrollSpyOptions,\n) => {\n  const currentScrollY = Signal(0);\n\n  scrollElement.addEventListener(\n    \"scroll\",\n    //debounce(\n    () => {\n      const scrollY = globalThis.scrollY;\n      const snapped = Math.round(scrollY / granularity) * granularity;\n      if (currentScrollY.get() !== snapped) {\n        currentScrollY.set(snapped);\n      }\n    },\n    //, debounceDelay),\n  );\n  return currentScrollY;\n};\n\ninterface ScrollSpyUpdateCustomPropsOptions extends ScrollSpyOptions {\n  recipient: HTMLElement;\n  scalarPropName?: string;\n  customVariable?: string;\n  booleanPropName?: string;\n}\n\nconst getViewPortHeight = () =>\n  Math.max(\n    document.documentElement.clientHeight || 1,\n    globalThis.innerHeight || 1,\n  );\n\nconst updateCustomPropOnScroll = (\n  {\n    recipient,\n    scalarPropName = \"data-scroll-y\",\n    customVariable = \"--scrollY\",\n    booleanPropName = \"data-scroll-y-is-snapped\",\n    ...rest\n  }: ScrollSpyUpdateCustomPropsOptions,\n) => {\n  const currentScrollY = createScrollSpy(rest);\n  let viewportHeight = getViewPortHeight();\n  document.body.addEventListener(\n    \"resize\",\n    () => viewportHeight = getViewPortHeight(),\n  );\n\n  recipient.classList.add(\"isListeningToScroll\");\n\n  const update = () => {\n    const scrollY = currentScrollY.get();\n    recipient.style.setProperty(customVariable, `${scrollY}px`);\n    recipient.setAttribute(scalarPropName, `${scrollY}`);\n    if (scrollY > 0) {\n      recipient.setAttribute(booleanPropName, \"\");\n      const scrolledScreens =\n        viewportHeight >= document.documentElement.scrollHeight\n          ? document.documentElement.scrollHeight\n          : Math.round(scrollY / viewportHeight);\n      if (scrolledScreens > 0) {\n        const className = `screenScrolled-${scrolledScreens}`;\n        if (!recipient.classList.contains(className)) {\n          recipient.classList.add(className);\n        }\n      }\n    } else {\n      recipient.removeAttribute(booleanPropName);\n    }\n  };\n  currentScrollY.on(update);\n  update();\n};\n\nupdateCustomPropOnScroll({\n  scrollElement: document,\n  recipient: document.documentElement,\n});\n", "import \"./components/togglerButton.client.ts\"; // needs to be at the beginning beause other things depend on it\nimport \"./components/betaMention.client.ts\";\nimport \"./components/carousel.client.ts\";\nimport \"./components/clapsButton.client.ts\";\nimport \"./components/codeBlock.client.ts\";\nimport \"./components/collapsibleList.client.ts\";\nimport \"./components/glossarySearch.client.ts\";\nimport \"./components/mainSearch.client.ts\";\nimport \"./components/passwordField.client.ts\";\nimport \"./components/promoGDSchool.client.ts\";\nimport \"./components/userMessages.client.ts\";\nimport \"./components/scrollingList.client.ts\";\nimport \"./components/nodeFlashCardShuffler.client.ts\";\nimport \"./components/itemSummaryBrowser.client.ts\";\nimport \"./components/mailingListCollector.client.ts\";\nimport \"./components/tableOfContents.client.ts\";\nimport \"./components/tabList.client.ts\";\nimport \"./components/themeToggle.client.ts\";\nimport \"./components/videoFile.client.ts\";\nimport \"./components/anchorClipboardButton.client.ts\"; // needs to be after ids have been inserted in the document\nimport \"./components/clipboardButton.client.ts\"; // needs to be after buttons have been created\nimport \"./components/clapsGame.client.ts\";\nimport \"./clientScript/scrollSpy.ts\";\n\n// import \"./prism.js\";\n\n/**/\n\n/*\nconst mainElement = document.querySelector(\"main\");\n\nmainElement &&\n  document.querySelectorAll(\"[popover]\").forEach((element) => {\n    element.addEventListener(\"toggle\", (event) => {\n      if (event.newState === \"open\") {\n        mainElement.setAttribute(\"inert\", \"\");\n      } else {\n        mainElement.removeAttribute(\"inert\");\n      }\n    });\n  });\n/**/\n\ndocument\n  .querySelectorAll<HTMLElement>(\".showWhenJSLoads\")\n  .forEach((element) => element.removeAttribute(\"hidden\"));\n\ndocument\n  .querySelectorAll<HTMLElement>(\".makeUsableWhenJSLoads\")\n  .forEach((element) => element.style.removeProperty(\"pointer-events\"));\n\ndocument\n  .querySelectorAll(\"a\")\n  .forEach(\n    (a) =>\n      a.getAttribute(\"href\") == globalThis.location.pathname &&\n      a.classList.add(\"active\")\n  );\n"],
  "mappings": "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",
  "names": ["noOp", "consoleMethodsKeys", "consoleMethods", "noOpLogger", "receiver", "k", "noOp", "SimpleConsole", "prefix", "args", "condition", "data", "columns", "simpleModuleLogger", "query", "enabledModules", "allModulesEnabled", "title", "color", "htmlBooleanAttributes", "htmlBooleanAttributesSet", "isHTMLBooleanAttribute", "value", "kebabize", "str", "$", "ofs", "escapeReplacements", "other", "getEscapeReplacement", "ch", "escapeHTML", "html", "encode", "protoOf", "objProto", "isObject", "value", "createElementDom", "tagName", "props", "element", "attributes", "children", "isObject", "k", "v", "fn", "listener", "event", "property", "kebabize", "escapeHTML", "classValue", "classes", "prop", "value", "isHTMLBooleanAttribute", "c", "createElementTemplate", "createElement", "tagName", "baseAttributes", "attributes", "children", "createElementsProxy", "createElement", "methods", "cache", "_target", "prop", "tagName", "htmlTagName", "kebabize", "isValidHTMLTag", "elementCreator", "createElementTemplate", "appendChildren", "parent", "children", "child", "clearAllChildren", "replaceAllChildren", "h", "createElementsProxy", "createElementDom", "debounce", "fn", "delay", "debounceTimeOut", "getClampedRandomInt", "max", "min", "pathRegex", "getFileTypeFromExtension", "extension", "DEFAULT_REGEX_VALUES", "splitPathStringToParts", "path", "_protocol", "dir", "filename", "basename", "dirname", "incomplete", "protocol", "fullPath", "href", "fileType", "SKIP", "CANCEL", "ABORT", "NONE", "identity", "value", "Signal", "value", "transform", "identity", "listeners", "signal", "fn", "newValue", "forceRefresh", "derivedValue", "SKIP", "oldValue", "MapSignal", "value", "transform", "identity", "signal", "Signal", "listenersForAdditions", "listenersForRemovals", "listenersForChange", "key", "oldData", "newData", "fn", "_delete", "LocalStorageSignalAdapter", "signal", "localStorageKey", "value", "TYPE_SUCCESS", "TYPE_ERROR", "TYPE_INFO", "TYPE_WARNING", "makeUserMessagesCollection", "signal", "LocalStorageSignalAdapter", "MapSignal", "add", "type", "message", "id", "_cache", "userMessagesCollection", "toURLParams", "values", "k", "v", "vv", "disableForm", "form", "length", "control", "enableForm", "handleSimpleFormSubmit", "callback", "event", "form", "action", "formName", "enctype", "method", "target", "values", "pickCorrectFetch", "type", "serialized", "json", "params", "toURLParams", "url", "enctype", "body", "defaultConfig", "autoFetchWhenSubmit", "config", "method", "classBusy", "doDisableForm", "doReEnableForm", "callback", "handleSimpleFormSubmit", "form", "promise", "disableForm", "response", "error", "enableForm", "_classCache", "processDomElementOnce", "selectors", "functor", "opts", "className", "root", "onError", "addedClass", "n", "elements", "element", "error", "ABORT", "onScrollStopped", "fn", "checkInterval", "root", "timer", "target", "onScroll", "cleanupUrlString", "path", "API", "base", "amount", "url", "cleanupUrlString", "data", "email", "name", "formData", "env", "key", "value", "API_URL", "getElementRelativePosition", "element", "scrollableParent", "parentRect", "elementRect", "isRelativePositionPartiallyWithinParent", "relative", "scrollIntoViewIfPartiallyVisible", "element", "scrollableParent", "relative", "getElementRelativePosition", "isRelativePositionPartiallyWithinParent", "makeNodeSignalBinder", "signal", "node", "mapper", "v", "wait", "milliseconds", "value", "resolve", "UnreachableCaseError", "value", "assertExhaustiveSwitch", "_", "ensureError", "error", "FetcherSignal", "initialValue", "signal", "Signal", "fetcherSignal", "url", "currentStatus", "assertExhaustiveSwitch", "response", "data", "error", "ensureError", "shuffleArray", "arr", "m", "i", "searchParamsToObj", "search", "single", "joinArrayChar", "result", "value", "key", "singleResult", "pick", "obj", "keys", "acc", "val", "querySelector", "selector", "options", "parent", "element", "querySelectorAll", "selector", "options", "parent", "elements", "isNotNull", "obj", "ensureAllElementsNotNull", "arr", "isNotNull", "DataBearingError", "data", "message", "prefersReducedMotion", "makeLogger", "simpleModuleLogger", "api", "API", "API_URL", "button", "h", "ToggleShowEvent", "isShown", "controls", "eventInitDict", "toggleButton", "expanded", "targetElementID", "targetElement", "targetToggledClassName", "event", "bodyClassName", "processTogglerButton", "processDomElementOnce", "classPrefix", "processDomElementOnce", "element", "button", "message", "timerTime", "setCurrent", "isCurrent", "processDomElementOnce", "carouselWrapper", "elements", "ensureAllElementsNotNull", "querySelector", "querySelectorAll", "playControlsContainer", "navigationDotsRaw", "slider", "liveRegion", "subElements", "slideButtons", "btn", "targetIndex", "controller", "pauseRequested", "startTimer", "previousButton", "nextButton", "pauseInput", "pauseLabel", "slides", "currentSlide", "nextSlide", "updateSlider", "prevSlide", "index", "pauseInterval", "stopTimer", "debounce", "newSlide", "prefersReducedMotion", "baseClass", "button", "span", "div", "add", "h4", "h", "dragElement", "elmnt", "pos1", "pos2", "pos3", "pos4", "dragMouseDown", "e", "closeDragElement", "elementDrag", "_startGame", "claps", "Signal", "cursors", "clapsPerClick", "shown", "upgradesAvailable", "mainButton", "makeNodeSignalBinder", "node", "val", "createConfetti", "incrementLater", "delay", "wait", "makeCursor", "index", "clicker", "increment", "promises", "j", "getClampedRandomInt", "acc", "promise", "value", "existingClickers", "i", "name", "description", "cost", "className", "signal", "showGame", "startGame", "pathname", "cleanupUrlString", "createConfetti", "randomRotationAngle", "getClampedRandomInt", "particlesContainer", "children", "particle", "getClapsOrRandom", "api", "amount", "initialAmount", "clapsOnPage", "initialFormattedAmount", "formatNumber", "maxClapsBeforeGameStarts", "claps", "Signal", "clapped", "startGame", "setClapButtonAmount", "formattedAmount", "total", "abbreviated", "bubble", "setAmount", "increase", "number", "processDomElementOnce", "button", "label", "cache", "event", "debounce", "add", "span", "wbr", "h", "classPrefix", "splitHTMLElementTextContent", "holderElement", "pathStr", "fileOnly", "pathParts", "splitPathStringToParts", "recipient", "label", "chunk", "splitHTMLElementTextContent", "add", "button", "h", "onRevealButtonClick", "makeRevealButton", "summary", "details", "id", "isOpen", "revealBtn", "processDomElementOnce", "el", "add", "h", "processCallout", "collapsiblesList", "caption", "content", "revealButton", "makeRevealButton", "processDomElementOnce", "SCORE", "MIN_SCORE", "MIN_TRIGRAM_SIMILARITY", "SUGGESTION_LENGTH_MIN", "SUGGESTION_LENGTH_MAX", "SUGGESTION_WORDS_MAX", "normalizeText", "value", "tokenize", "removeDuplicates", "values", "normalizeList", "expandWithTokens", "humanizeText", "toSentenceCase", "humanized", "lower", "FILTER_ONLY_SCORE", "generateTrigrams", "text", "trigrams", "padded", "i", "normalizeEntry", "item", "title", "titleTokens", "keywords", "keywordTokens", "tags", "tagTokens", "categories", "filterableFields", "isArchived", "allPhraseValues", "allTokensWithTrigrams", "buildSuggestionEntries", "normalizedEntries", "pool", "addCandidate", "displayValue", "wordCount", "normalizedValue", "entry", "a", "b", "CATEGORY_TO_FIELD", "matchesFilters", "filters", "category", "allowedValues", "fieldKey", "fieldValue", "hasMatch", "hasActiveFilters", "set", "sortSearchResults", "aIsGodot4", "bIsGodot4", "sortByTitle", "trigramSimilarity", "trigramsA", "trigramsB", "minSimilarity", "intersectionSize", "trigram", "unionSize", "similarity", "evaluateFullQuery", "normalizedQuery", "bestScore", "candidate", "evaluateToken", "token", "queryTrigrams", "word", "tag", "score", "kw", "cat", "normalizedSimilarity", "typoScore", "scoreEntry", "tokens", "tokenTrigrams", "total", "tokenScore", "createLibrarySearchEngine", "items", "normalized", "suggestionEntries", "filter", "options", "results", "query", "sanitized", "filtersEnabled", "minScore", "activeResults", "archivedResults", "result", "limit", "prefixMatches", "substringMatches", "suggestion", "normalizeGlossaryItem", "term", "createGlossarySearchEngine", "termTrigrams", "t", "classPrefixSearch", "classPrefixList", "setElementDisabled", "doDisable", "processDomElementOnce", "element", "form", "event", "input", "noSearchResultsElement", "dataURL", "searchTerms", "el", "tocAnchors", "a", "letter", "augmentedAnchor", "searchInputAnchors", "sections", "section", "onSearchLoaded", "data", "engine", "createGlossarySearchEngine", "onInputEnter", "debounce", "query", "s", "term", "results", "slug", "terms", "key", "searchLoadedData", "FetcherSignal", "status", "createId", "prefix", "createSuggestionsDropdown", "classPrefix", "container", "input", "onSelect", "suggestions", "highlightedIndex", "buttons", "activeClass", "listId", "list", "optionIdPrefix", "clear", "select", "index", "suggestion", "setHighlighted", "button", "idx", "isActive", "activeButton", "render", "items", "entry", "e", "handleKey", "event", "target", "span", "replace", "a", "em", "h", "classPrefix", "processDomElementOnce", "searchWrapper", "enableUI", "loadingOverlay", "querySelector", "dataURL", "DataBearingError", "elements", "gridListId", "summaryId", "ensureAllElementsNotNull", "gridList", "summary", "searchForm", "searchInput", "filtersContainer", "selectedTermsContainer", "suggestionsContainer", "cardsBeforeAugmentation", "querySelectorAll", "activeFiltersMap", "filtersElements", "allFilterElements", "allSelectedTermLabels", "clearAllButton", "Signal", "createFilterCategory", "selected", "values", "newSelected", "newValues", "input", "val", "filters", "filtersById", "inputOrButton", "categoryName", "category", "currentValues", "button", "controlledInput", "label", "htmlFor", "processedFilters", "_categoryName", "resetCategoryAndCancelEvent", "event", "shouldBeChecked", "resetAll", "newMap", "anyValueSelected", "getFiltersObject", "cards", "clearCards", "cardAugmentations", "score", "augmentCard", "card", "item", "searchResultsAmountState", "searchLoadedDataState", "FetcherSignal", "onSearchResultsChanged", "results", "shown", "i", "onSearchAmountChanged", "amountOfValidResults", "total", "noResultsClass", "hasAppliedFilters", "searchString", "keywords", "value", "onSearchDataLoaded", "data", "items", "engine", "createLibrarySearchEngine", "runSearch", "query", "currentQueryState", "updateResults", "hasQuery", "hasFilters", "s", "setQuery", "searchPattern", "updateHistory", "suggestions", "createSuggestionsDropdown", "updateSuggestions", "debounce", "nextSuggestions", "e", "searchQuery", "pick", "searchParamsToObj", "status", "error", "restoreUI", "add", "button", "div", "span", "h", "setPasswordButtonText", "text", "onPasswordButtonClick", "_event", "controlId", "element", "expanded", "processDomElementOnce", "input", "id", "buttonLabel", "revealButton", "container", "add", "button", "div", "span", "h", "classPrefix", "container", "addUserMessageElement", "id", "message", "type", "popup", "event", "target", "userMessagesCollection", "logger", "makeLogger", "processDomElementOnce", "slider", "grid", "controls", "prevButton", "nextButton", "carouselWindowWidth", "pages", "currentPage", "init", "navigate", "debounce", "calculateAndNavigate", "calculateDimensions", "carouselInnerWidth", "updateButtons", "direction", "nextPage", "navigateToPage", "pageNumber", "p", "span", "ul", "li", "div", "h4", "h3", "h", "classPrefix", "iconsNamesMap", "getIconPath", "name", "NodeFlashCard", "category", "title", "use_when", "examples", "example", "replace", "h", "nodeEssentialsData", "FetcherSignal", "processDomElementOnce", "element", "contentPane", "buttons", "grid", "dataURL", "setStateLoading", "loading", "button", "data", "currentIndex", "pickThreeNextCards", "nextIndex", "assignNodeData", "nextCards", "NodeFlashCard", "fakeLoadAndPickThree", "getClampedRandomInt", "onClick", "_event", "incomingData", "shuffleArray", "remainder", "itemsToAdd", "lastItems", "status", "element", "processDomElementOnce", "form", "messagesContainer", "messages", "messageAlreadySubscribed", "messageSuccess", "messageError", "element", "newElement", "jsonInput", "onSubmit", "autoFetchWhenSubmit", "err", "result", "classPrefix", "CLASS_ANCHOR_SCROLLED_PAST", "CLASS_CURRENT_LIST_ITEM", "CLASS_SUBHEADINGS_LIST", "classPrefix", "CLASS_SUBHEADINGS_LIST_CONTAINER", "CLASS_ANCHOR_LINK", "CLASS_ANCHOR_LINK_LEVEL_PREFIX", "CLASS_LIST_ITEM", "CLASS_LIST_ITEM_LEVEL_PREFIX", "CLASS_FOLD_UNFOLD_BUTTON", "SIDEBAR_CLOSED_BODY_CLASS", "CLASS_SCROLLING_PANE", "getViewPortSizeFromCss", "fallBackMaxWidth", "size", "setIsScrolledPast", "isScrolledPast", "CLASS_ANCHOR_SCROLLED_PAST", "setIsCurrent", "isCurrent", "parent", "CLASS_CURRENT_LIST_ITEM", "scrollIntoViewIfPartiallyVisible", "revealButton", "sortDomElementsByVerticalPosition", "a", "b", "getDirectChildButton", "element", "child", "CLASS_FOLD_UNFOLD_BUTTON", "processDomElementOnce", "root", "headings", "headingsIds", "anchors", "scrollingParent", "CLASS_SCROLLING_PANE", "removeAllCurrent", "el", "suspendObserverUpdates", "anchorClicked", "onScrollStopped", "CLASS_ANCHOR_LINK", "anchor", "href", "heading", "id", "revealButtons", "currentElement", "active", "observer", "entries", "entry", "index", "primaryActiveId", "reachedCurrent", "h", "classPrefix", "button", "event", "SIDEBAR_CLOSED_BODY_CLASS", "getViewPortSizeFromCss", "augmentTabList", "tabList", "tabFocus", "cache", "tabs", "tab", "index", "controlledId", "controlledElement", "setCurrentTabFromFocus", "t", "tabNext", "tabPrevious", "setNewTabFocus", "newFocus", "e", "onHashChange", "processDomElementOnce", "button", "isDark", "video", "a", "span", "add", "h", "pageTitle", "pageUrl", "processDomElementOnce", "element", "anchor", "title", "dataClipboard", "clipboardButton", "event", "unclickButton", "button", "onclipboardButtonClick", "_event", "value", "clipboard", "processClipboardButton", "processDomElementOnce", "createScrollSpy", "scrollElement", "granularity", "currentScrollY", "Signal", "scrollY", "snapped", "getViewPortHeight", "updateCustomPropOnScroll", "recipient", "scalarPropName", "customVariable", "booleanPropName", "rest", "viewportHeight", "update", "scrolledScreens", "className", "element", "a"]
}
